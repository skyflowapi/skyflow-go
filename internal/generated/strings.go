// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/v2/internal/generated/internal"
)

type DeidentifyStringRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// String to de-identify.
	Text            string           `json:"text" url:"-"`
	ConfigurationId *ConfigurationId `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes     `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenType       `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex      `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex   `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations `json:"transformations,omitempty" url:"-"`
}

type ReidentifyStringRequest struct {
	// String to re-identify.
	Text string `json:"text" url:"-"`
	// ID of the vault where the entities are stored.
	VaultId string `json:"vault_id" url:"-"`
	// Mapping of perferred data formatting options to entity types. Returned values are dependent on the configuration of the vault storing the data and the permissions of the user or account making the request.
	Format *ReidentifyStringRequestFormat `json:"format,omitempty" url:"-"`
}

// Response to deidentify a string.
type DeidentifyStringResponse struct {
	// De-identified text.
	ProcessedText string `json:"processed_text" url:"processed_text"`
	// Detected entities.
	Entities []*DetectedEntity `json:"entities" url:"entities"`
	// Number of words from the input text.
	WordCount int `json:"word_count" url:"word_count"`
	// Number of characters from the input text.
	CharacterCount int `json:"character_count" url:"character_count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyStringResponse) GetProcessedText() string {
	if d == nil {
		return ""
	}
	return d.ProcessedText
}

func (d *DeidentifyStringResponse) GetEntities() []*DetectedEntity {
	if d == nil {
		return nil
	}
	return d.Entities
}

func (d *DeidentifyStringResponse) GetWordCount() int {
	if d == nil {
		return 0
	}
	return d.WordCount
}

func (d *DeidentifyStringResponse) GetCharacterCount() int {
	if d == nil {
		return 0
	}
	return d.CharacterCount
}

func (d *DeidentifyStringResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyStringResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyStringResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyStringResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyStringResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Detected entities.
type DetectedEntity struct {
	// Processed text of the entity.
	Token *string `json:"token,omitempty" url:"token,omitempty"`
	// Original text of the entity.
	Value    *string         `json:"value,omitempty" url:"value,omitempty"`
	Location *EntityLocation `json:"location,omitempty" url:"location,omitempty"`
	// Highest-rated label.
	EntityType *string `json:"entity_type,omitempty" url:"entity_type,omitempty"`
	// entity_scores and their scores.
	EntityScores map[string]float64 `json:"entity_scores,omitempty" url:"entity_scores,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DetectedEntity) GetToken() *string {
	if d == nil {
		return nil
	}
	return d.Token
}

func (d *DetectedEntity) GetValue() *string {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DetectedEntity) GetLocation() *EntityLocation {
	if d == nil {
		return nil
	}
	return d.Location
}

func (d *DetectedEntity) GetEntityType() *string {
	if d == nil {
		return nil
	}
	return d.EntityType
}

func (d *DetectedEntity) GetEntityScores() map[string]float64 {
	if d == nil {
		return nil
	}
	return d.EntityScores
}

func (d *DetectedEntity) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetectedEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler DetectedEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetectedEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetectedEntity) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Locations of an entity in the text.
type EntityLocation struct {
	// Index of the first character of the string in the original text.
	StartIndex *int `json:"start_index,omitempty" url:"start_index,omitempty"`
	// Index of the last character of the string in the original text.
	EndIndex *int `json:"end_index,omitempty" url:"end_index,omitempty"`
	// Index of the first character of the string in the processed text.
	StartIndexProcessed *int `json:"start_index_processed,omitempty" url:"start_index_processed,omitempty"`
	// Index of the last character of the string in the processed text.
	EndIndexProcessed *int `json:"end_index_processed,omitempty" url:"end_index_processed,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityLocation) GetStartIndex() *int {
	if e == nil {
		return nil
	}
	return e.StartIndex
}

func (e *EntityLocation) GetEndIndex() *int {
	if e == nil {
		return nil
	}
	return e.EndIndex
}

func (e *EntityLocation) GetStartIndexProcessed() *int {
	if e == nil {
		return nil
	}
	return e.StartIndexProcessed
}

func (e *EntityLocation) GetEndIndexProcessed() *int {
	if e == nil {
		return nil
	}
	return e.EndIndexProcessed
}

func (e *EntityLocation) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityLocation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityLocation) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Re-identify string response.
type ReidentifyStringResponse struct {
	// Re-identified text.
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyStringResponse) GetText() *string {
	if r == nil {
		return nil
	}
	return r.Text
}

func (r *ReidentifyStringResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyStringResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ReidentifyStringResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReidentifyStringResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyStringResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Mapping of tokens to generation for detected entities. Can't be specified together with `token_type`.
type TokenType struct {
	Default *TokenTypeDefault `json:"default,omitempty" url:"default,omitempty"`
	// Entity types to replace with vault tokens.
	VaultToken []EntityType `json:"vault_token,omitempty" url:"vault_token,omitempty"`
	// Entity types to replace with entity tokens with unique counters.
	EntityUnqCounter []EntityType `json:"entity_unq_counter,omitempty" url:"entity_unq_counter,omitempty"`
	// Entity types to replace with entity tokens.
	EntityOnly []EntityType `json:"entity_only,omitempty" url:"entity_only,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenType) GetDefault() *TokenTypeDefault {
	if t == nil {
		return nil
	}
	return t.Default
}

func (t *TokenType) GetVaultToken() []EntityType {
	if t == nil {
		return nil
	}
	return t.VaultToken
}

func (t *TokenType) GetEntityUnqCounter() []EntityType {
	if t == nil {
		return nil
	}
	return t.EntityUnqCounter
}

func (t *TokenType) GetEntityOnly() []EntityType {
	if t == nil {
		return nil
	}
	return t.EntityOnly
}

func (t *TokenType) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenType) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenType) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenTypeDefault string

const (
	TokenTypeDefaultEntityOnly       TokenTypeDefault = "entity_only"
	TokenTypeDefaultEntityUnqCounter TokenTypeDefault = "entity_unq_counter"
	TokenTypeDefaultVaultToken       TokenTypeDefault = "vault_token"
)

func NewTokenTypeDefaultFromString(s string) (TokenTypeDefault, error) {
	switch s {
	case "entity_only":
		return TokenTypeDefaultEntityOnly, nil
	case "entity_unq_counter":
		return TokenTypeDefaultEntityUnqCounter, nil
	case "vault_token":
		return TokenTypeDefaultVaultToken, nil
	}
	var t TokenTypeDefault
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenTypeDefault) Ptr() *TokenTypeDefault {
	return &t
}

// Mapping of perferred data formatting options to entity types. Returned values are dependent on the configuration of the vault storing the data and the permissions of the user or account making the request.
type ReidentifyStringRequestFormat struct {
	// Entity types to fully redact.
	Redacted []EntityType `json:"redacted,omitempty" url:"redacted,omitempty"`
	// Entity types to mask.
	Masked []EntityType `json:"masked,omitempty" url:"masked,omitempty"`
	// Entity types to return in plaintext.
	Plaintext []EntityType `json:"plaintext,omitempty" url:"plaintext,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyStringRequestFormat) GetRedacted() []EntityType {
	if r == nil {
		return nil
	}
	return r.Redacted
}

func (r *ReidentifyStringRequestFormat) GetMasked() []EntityType {
	if r == nil {
		return nil
	}
	return r.Masked
}

func (r *ReidentifyStringRequestFormat) GetPlaintext() []EntityType {
	if r == nil {
		return nil
	}
	return r.Plaintext
}

func (r *ReidentifyStringRequestFormat) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyStringRequestFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler ReidentifyStringRequestFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReidentifyStringRequestFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyStringRequestFormat) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
