// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/v2/internal/generated/fern-flowdb-sdk/internal"
)

type V1DeleteRequest struct {
	// ID of the vault where data is being deleted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being deleted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be deleted
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
}

type V1FlowDeleteTokenRequest struct {
	// Vault ID
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token value
	Tokens []string `json:"tokens,omitempty" url:"-"`
}

type V1FlowDetokenizeRequest struct {
	// ID of the vault where detokenizing
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token to be detokenized
	Tokens []string `json:"tokens,omitempty" url:"-"`
	// List of token groups to be redacted.
	TokenGroupRedactions []*V1TokenGroupRedactions `json:"tokenGroupRedactions,omitempty" url:"-"`
}

type V1GetRequest struct {
	// ID of the vault where data is being fetched
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being fetched
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be fetched
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
	// List of columns to be redacted.
	ColumnRedactions []*V1ColumnRedactions `json:"columnRedactions,omitempty" url:"-"`
	// List of columns to be fetched.
	Columns []string `json:"columns,omitempty" url:"-"`
}

type V1InsertRequest struct {
	// ID of the vault where data is being inserted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being inserted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be inserted in the vault
	Records []*V1InsertRecordData `json:"records,omitempty" url:"-"`
	// Name of a unique columns in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.
	Upsert []string `json:"upsert,omitempty" url:"-"`
}

type V1FlowTokenizeRequest struct {
	// Vault ID.
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Data to be tokenized
	Data []*V1FlowTokenizeRequestObject `json:"data,omitempty" url:"-"`
}

type FlowEnumDataType string

const (
	FlowEnumDataTypeUndefinedDatatype FlowEnumDataType = "UNDEFINED_DATATYPE"
	FlowEnumDataTypeString            FlowEnumDataType = "STRING"
	FlowEnumDataTypeNumber            FlowEnumDataType = "NUMBER"
	FlowEnumDataTypeBool              FlowEnumDataType = "BOOL"
	FlowEnumDataTypeJson              FlowEnumDataType = "JSON"
)

func NewFlowEnumDataTypeFromString(s string) (FlowEnumDataType, error) {
	switch s {
	case "UNDEFINED_DATATYPE":
		return FlowEnumDataTypeUndefinedDatatype, nil
	case "STRING":
		return FlowEnumDataTypeString, nil
	case "NUMBER":
		return FlowEnumDataTypeNumber, nil
	case "BOOL":
		return FlowEnumDataTypeBool, nil
	case "JSON":
		return FlowEnumDataTypeJson, nil
	}
	var t FlowEnumDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FlowEnumDataType) Ptr() *FlowEnumDataType {
	return &f
}

type FlowTokenizeResponseObjectToken struct {
	// Token group Name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Token value
	Token *string `json:"token,omitempty" url:"token,omitempty"`
	// Error if tokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowTokenizeResponseObjectToken) GetTokenGroupName() *string {
	if f == nil {
		return nil
	}
	return f.TokenGroupName
}

func (f *FlowTokenizeResponseObjectToken) GetToken() *string {
	if f == nil {
		return nil
	}
	return f.Token
}

func (f *FlowTokenizeResponseObjectToken) GetError() *string {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FlowTokenizeResponseObjectToken) GetHttpCode() *int {
	if f == nil {
		return nil
	}
	return f.HttpCode
}

func (f *FlowTokenizeResponseObjectToken) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowTokenizeResponseObjectToken) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowTokenizeResponseObjectToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowTokenizeResponseObjectToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowTokenizeResponseObjectToken) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type V1ColumnRedactions struct {
	// Name of the column to be redacted
	ColumnName *string `json:"columnName,omitempty" url:"columnName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1ColumnRedactions) GetColumnName() *string {
	if v == nil {
		return nil
	}
	return v.ColumnName
}

func (v *V1ColumnRedactions) GetRedaction() *string {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1ColumnRedactions) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ColumnRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ColumnRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ColumnRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ColumnRedactions) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteResponse struct {
	// List of deleted records with skyflow ID and any partial errors.
	Records []*V1DeleteResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteResponse) GetRecords() []*V1DeleteResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1DeleteResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteResponseObject struct {
	// Skyflow ID for the deleted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteResponseObject) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1DeleteResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DeleteResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1DeleteResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteTokenResponseObject struct {
	// Token value
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Error if deletion failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteTokenResponseObject) GetValue() *string {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1DeleteTokenResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DeleteTokenResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1DeleteTokenResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteTokenResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteTokenResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteTokenResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteTokenResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowDeleteTokenResponse struct {
	// Tokens data for Delete
	Tokens []*V1DeleteTokenResponseObject `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowDeleteTokenResponse) GetTokens() []*V1DeleteTokenResponseObject {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1FlowDeleteTokenResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowDeleteTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowDeleteTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowDeleteTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowDeleteTokenResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowDetokenizeResponse struct {
	// Detokenized data
	Response []*V1FlowDetokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowDetokenizeResponse) GetResponse() []*V1FlowDetokenizeResponseObject {
	if v == nil {
		return nil
	}
	return v.Response
}

func (v *V1FlowDetokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowDetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowDetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowDetokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowDetokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowDetokenizeResponseObject struct {
	// Token to be detokenized
	Token *string     `json:"token,omitempty" url:"token,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token group name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Error if detokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowDetokenizeResponseObject) GetToken() *string {
	if v == nil {
		return nil
	}
	return v.Token
}

func (v *V1FlowDetokenizeResponseObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1FlowDetokenizeResponseObject) GetTokenGroupName() *string {
	if v == nil {
		return nil
	}
	return v.TokenGroupName
}

func (v *V1FlowDetokenizeResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1FlowDetokenizeResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1FlowDetokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowDetokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowDetokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowDetokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowDetokenizeResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowTokenizeRequestObject struct {
	Value    interface{}       `json:"value,omitempty" url:"value,omitempty"`
	DataType *FlowEnumDataType `json:"dataType,omitempty" url:"dataType,omitempty"`
	// List of token group names
	TokenGroupNames []string `json:"tokenGroupNames,omitempty" url:"tokenGroupNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowTokenizeRequestObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1FlowTokenizeRequestObject) GetDataType() *FlowEnumDataType {
	if v == nil {
		return nil
	}
	return v.DataType
}

func (v *V1FlowTokenizeRequestObject) GetTokenGroupNames() []string {
	if v == nil {
		return nil
	}
	return v.TokenGroupNames
}

func (v *V1FlowTokenizeRequestObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowTokenizeRequestObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowTokenizeRequestObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowTokenizeRequestObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowTokenizeRequestObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowTokenizeResponse struct {
	// Tokenized data
	Response []*V1FlowTokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowTokenizeResponse) GetResponse() []*V1FlowTokenizeResponseObject {
	if v == nil {
		return nil
	}
	return v.Response
}

func (v *V1FlowTokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowTokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowTokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowTokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowTokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1FlowTokenizeResponseObject struct {
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token value
	Tokens []*FlowTokenizeResponseObjectToken `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1FlowTokenizeResponseObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1FlowTokenizeResponseObject) GetTokens() []*FlowTokenizeResponseObjectToken {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1FlowTokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1FlowTokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1FlowTokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1FlowTokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1FlowTokenizeResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1GetResponse struct {
	// List of fetched records with skyflow ID, tokens, data, and any partial errors
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1GetResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1GetResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1GetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1GetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1GetResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1GetResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1InsertRecordData struct {
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1InsertRecordData) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1InsertRecordData) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1InsertRecordData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InsertRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InsertRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InsertRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InsertRecordData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1InsertResponse struct {
	// List of inserted records with skyflow ID, tokens, data, and any partial errors.
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1InsertResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1InsertResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InsertResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1RecordResponseObject struct {
	// Skyflow ID for the inserted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1RecordResponseObject) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1RecordResponseObject) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1RecordResponseObject) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1RecordResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1RecordResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1RecordResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1RecordResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1RecordResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1RecordResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1RecordResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenGroupRedactions struct {
	// Name of the token group to be redacted
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenGroupRedactions) GetTokenGroupName() *string {
	if v == nil {
		return nil
	}
	return v.TokenGroupName
}

func (v *V1TokenGroupRedactions) GetRedaction() *string {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1TokenGroupRedactions) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenGroupRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenGroupRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenGroupRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenGroupRedactions) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateRecordData struct {
	// Skyflow ID for the record to be updated
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// List of data row wise that is to be updated in the vault
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1UpdateRecordData) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1UpdateRecordData) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1UpdateRecordData) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1UpdateRecordData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateRecordData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateResponse struct {
	// List of updated records with skyflow ID, tokens, data, and any partial errors
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1UpdateResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1UpdateResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateRequest struct {
	// ID of the vault where data is being updated
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being updated
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be updated in the vault
	Records []*V1UpdateRecordData `json:"records,omitempty" url:"-"`
}
