// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/v2/internal/generated/internal"
)

type V1DetokenizePayload struct {
	// Detokenization details.
	DetokenizationParameters []*V1DetokenizeRecordRequest `json:"detokenizationParameters,omitempty" url:"-"`
	// If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
	DownloadUrl *bool `json:"downloadURL,omitempty" url:"-"`
	// If `true`, the detokenization request continues even if an error occurs.
	ContinueOnError *bool `json:"continueOnError,omitempty" url:"-"`
}

type V1TokenizePayload struct {
	// Tokenization details.
	TokenizationParameters []*V1TokenizeRecordRequest `json:"tokenizationParameters,omitempty" url:"-"`
}

type DetokenizeRecordResponseValueType string

const (
	DetokenizeRecordResponseValueTypeNone     DetokenizeRecordResponseValueType = "NONE"
	DetokenizeRecordResponseValueTypeString   DetokenizeRecordResponseValueType = "STRING"
	DetokenizeRecordResponseValueTypeInteger  DetokenizeRecordResponseValueType = "INTEGER"
	DetokenizeRecordResponseValueTypeFloat    DetokenizeRecordResponseValueType = "FLOAT"
	DetokenizeRecordResponseValueTypeBool     DetokenizeRecordResponseValueType = "BOOL"
	DetokenizeRecordResponseValueTypeDatetime DetokenizeRecordResponseValueType = "DATETIME"
	DetokenizeRecordResponseValueTypeJson     DetokenizeRecordResponseValueType = "JSON"
	DetokenizeRecordResponseValueTypeArray    DetokenizeRecordResponseValueType = "ARRAY"
	DetokenizeRecordResponseValueTypeDate     DetokenizeRecordResponseValueType = "DATE"
)

func NewDetokenizeRecordResponseValueTypeFromString(s string) (DetokenizeRecordResponseValueType, error) {
	switch s {
	case "NONE":
		return DetokenizeRecordResponseValueTypeNone, nil
	case "STRING":
		return DetokenizeRecordResponseValueTypeString, nil
	case "INTEGER":
		return DetokenizeRecordResponseValueTypeInteger, nil
	case "FLOAT":
		return DetokenizeRecordResponseValueTypeFloat, nil
	case "BOOL":
		return DetokenizeRecordResponseValueTypeBool, nil
	case "DATETIME":
		return DetokenizeRecordResponseValueTypeDatetime, nil
	case "JSON":
		return DetokenizeRecordResponseValueTypeJson, nil
	case "ARRAY":
		return DetokenizeRecordResponseValueTypeArray, nil
	case "DATE":
		return DetokenizeRecordResponseValueTypeDate, nil
	}
	var t DetokenizeRecordResponseValueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetokenizeRecordResponseValueType) Ptr() *DetokenizeRecordResponseValueType {
	return &d
}

type V1DetokenizeRecordRequest struct {
	// Token that identifies the record to detokenize.
	Token     *string                 `json:"token,omitempty" url:"token,omitempty"`
	Redaction *RedactionEnumRedaction `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DetokenizeRecordRequest) GetToken() *string {
	if v == nil {
		return nil
	}
	return v.Token
}

func (v *V1DetokenizeRecordRequest) GetRedaction() *RedactionEnumRedaction {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1DetokenizeRecordRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DetokenizeRecordRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DetokenizeRecordRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DetokenizeRecordRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DetokenizeRecordRequest) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DetokenizeRecordResponse struct {
	// Token of the record.
	Token     *string                            `json:"token,omitempty" url:"token,omitempty"`
	ValueType *DetokenizeRecordResponseValueType `json:"valueType,omitempty" url:"valueType,omitempty"`
	// Data corresponding to the token.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Error if token isn't found.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DetokenizeRecordResponse) GetToken() *string {
	if v == nil {
		return nil
	}
	return v.Token
}

func (v *V1DetokenizeRecordResponse) GetValueType() *DetokenizeRecordResponseValueType {
	if v == nil {
		return nil
	}
	return v.ValueType
}

func (v *V1DetokenizeRecordResponse) GetValue() *string {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1DetokenizeRecordResponse) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DetokenizeRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DetokenizeRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DetokenizeRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DetokenizeRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DetokenizeRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DetokenizeResponse struct {
	// Records corresponding to the specified tokens.
	Records []*V1DetokenizeRecordResponse `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DetokenizeResponse) GetRecords() []*V1DetokenizeRecordResponse {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1DetokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DetokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DetokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeRecordRequest struct {
	// Existing value to return a token for.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Name of the column group that the value belongs to.
	ColumnGroup *string `json:"columnGroup,omitempty" url:"columnGroup,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeRecordRequest) GetValue() *string {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1TokenizeRecordRequest) GetColumnGroup() *string {
	if v == nil {
		return nil
	}
	return v.ColumnGroup
}

func (v *V1TokenizeRecordRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeRecordRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeRecordRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeRecordRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeRecordRequest) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeRecordResponse struct {
	// Token corresponding to a value.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeRecordResponse) GetToken() *string {
	if v == nil {
		return nil
	}
	return v.Token
}

func (v *V1TokenizeRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeResponse struct {
	// Tokens corresponding to the specified values.
	Records []*V1TokenizeRecordResponse `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeResponse) GetRecords() []*V1TokenizeRecordResponse {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1TokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
