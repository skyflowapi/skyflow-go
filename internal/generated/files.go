// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/v2/internal/generated/internal"
)

type DeidentifyAudioRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyAudioRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId            `json:"configuration_id,omitempty" url:"-"`
	// If `true`, includes processed audio file in the response.
	OutputProcessedAudio *bool `json:"output_processed_audio,omitempty" url:"-"`
	// Type of transcription to output.
	OutputTranscription *DeidentifyAudioRequestOutputTranscription `json:"output_transcription,omitempty" url:"-"`
	// Relative loudness of the bleep in dB. Positive values increase its loudness, and negative values decrease it.
	BleepGain *float64 `json:"bleep_gain,omitempty" url:"-"`
	// The pitch of the bleep sound, in Hz. The higher the number, the higher the pitch.
	BleepFrequency *float64 `json:"bleep_frequency,omitempty" url:"-"`
	// Padding added to the beginning of a bleep, in seconds.
	BleepStartPadding *float64 `json:"bleep_start_padding,omitempty" url:"-"`
	// Padding added to the end of a bleep, in seconds.
	BleepStopPadding *float64               `json:"bleep_stop_padding,omitempty" url:"-"`
	EntityTypes      *EntityTypes           `json:"entity_types,omitempty" url:"-"`
	TokenType        *TokenTypeWithoutVault `json:"token_type,omitempty" url:"-"`
	AllowRegex       *AllowRegex            `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex    *RestrictRegex         `json:"restrict_regex,omitempty" url:"-"`
	Transformations  *Transformations       `json:"transformations,omitempty" url:"-"`
}

type DeidentifyDocumentRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyDocumentRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId               `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes                   `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault         `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                    `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex                 `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations               `json:"transformations,omitempty" url:"-"`
}

type DeidentifyFileRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyFileRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId           `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes               `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault     `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex             `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations           `json:"transformations,omitempty" url:"-"`
}

type DeidentifyImageRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyImageRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId            `json:"configuration_id,omitempty" url:"-"`
	// If `true`, includes processed image in the output.
	OutputProcessedImage *bool `json:"output_processed_image,omitempty" url:"-"`
	// If `true`, includes OCR text output in the response.
	OutputOcrText *bool `json:"output_ocr_text,omitempty" url:"-"`
	// Method to mask the entities in the image.
	MaskingMethod   *DeidentifyImageRequestMaskingMethod `json:"masking_method,omitempty" url:"-"`
	EntityTypes     *EntityTypes                         `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault               `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                          `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex                       `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations                     `json:"transformations,omitempty" url:"-"`
}

type DeidentifyPdfRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyPdfRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId          `json:"configuration_id,omitempty" url:"-"`
	// Pixel density at which to process the PDF file.
	Density *int `json:"density,omitempty" url:"-"`
	// Max resolution at which to process the PDF file.
	MaxResolution   *int                   `json:"max_resolution,omitempty" url:"-"`
	EntityTypes     *EntityTypes           `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex            `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex         `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations       `json:"transformations,omitempty" url:"-"`
}

type DeidentifyPresentationRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyPresentationRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId                   `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes                       `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault             `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                        `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex                     `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations                   `json:"transformations,omitempty" url:"-"`
}

type DeidentifySpreadsheetRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifySpreadsheetRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId                  `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes                      `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault            `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                       `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex                    `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations                  `json:"transformations,omitempty" url:"-"`
}

type DeidentifyStructuredTextRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyStructuredTextRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId                     `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes                         `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault               `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                          `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex                       `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations                     `json:"transformations,omitempty" url:"-"`
}

type DeidentifyTextRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to de-identify. Files are specified as Base64-encoded data.
	File            *DeidentifyTextRequestFile `json:"file,omitempty" url:"-"`
	ConfigurationId *ConfigurationId           `json:"configuration_id,omitempty" url:"-"`
	EntityTypes     *EntityTypes               `json:"entity_types,omitempty" url:"-"`
	TokenType       *TokenTypeWithoutVault     `json:"token_type,omitempty" url:"-"`
	AllowRegex      *AllowRegex                `json:"allow_regex,omitempty" url:"-"`
	RestrictRegex   *RestrictRegex             `json:"restrict_regex,omitempty" url:"-"`
	Transformations *Transformations           `json:"transformations,omitempty" url:"-"`
}

type GetRunRequest struct {
	// ID of the vault.
	VaultId ResourceId `json:"-" url:"vault_id"`
}

type ReidentifyFileRequest struct {
	VaultId VaultId `json:"vault_id" url:"-"`
	// File to re-identify. Files are specified as Base64-encoded data or an EFS path.
	File *ReidentifyFileRequestFile `json:"file,omitempty" url:"-"`
	// Mapping of preferred data formatting options to entity types. Returned values are dependent on the configuration of the vault storing the data and the permissions of the user or account making the request.
	Format *ReidentifyFileRequestFormat `json:"format,omitempty" url:"-"`
}

// Details and contents of the processed file.
type DeidentifyFileOutput struct {
	// URL or base64-encoded data of the output.
	ProcessedFile *string `json:"processed_file,omitempty" url:"processed_file,omitempty"`
	// Type of the processed file.
	ProcessedFileType *DeidentifyFileOutputProcessedFileType `json:"processed_file_type,omitempty" url:"processed_file_type,omitempty"`
	// Extension of the processed file.
	ProcessedFileExtension *string `json:"processed_file_extension,omitempty" url:"processed_file_extension,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyFileOutput) GetProcessedFile() *string {
	if d == nil {
		return nil
	}
	return d.ProcessedFile
}

func (d *DeidentifyFileOutput) GetProcessedFileType() *DeidentifyFileOutputProcessedFileType {
	if d == nil {
		return nil
	}
	return d.ProcessedFileType
}

func (d *DeidentifyFileOutput) GetProcessedFileExtension() *string {
	if d == nil {
		return nil
	}
	return d.ProcessedFileExtension
}

func (d *DeidentifyFileOutput) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyFileOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyFileOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyFileOutput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyFileOutput) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Type of the processed file.
type DeidentifyFileOutputProcessedFileType string

const (
	DeidentifyFileOutputProcessedFileTypeEntities                             DeidentifyFileOutputProcessedFileType = "entities"
	DeidentifyFileOutputProcessedFileTypePlaintextTranscription               DeidentifyFileOutputProcessedFileType = "plaintext_transcription"
	DeidentifyFileOutputProcessedFileTypeRedactedAudio                        DeidentifyFileOutputProcessedFileType = "redacted_audio"
	DeidentifyFileOutputProcessedFileTypeRedactedDiarizedTranscription        DeidentifyFileOutputProcessedFileType = "redacted_diarized_transcription"
	DeidentifyFileOutputProcessedFileTypeRedactedFile                         DeidentifyFileOutputProcessedFileType = "redacted_file"
	DeidentifyFileOutputProcessedFileTypeRedactedImage                        DeidentifyFileOutputProcessedFileType = "redacted_image"
	DeidentifyFileOutputProcessedFileTypeRedactedMedicalDiarizedTranscription DeidentifyFileOutputProcessedFileType = "redacted_medical_diarized_transcription"
	DeidentifyFileOutputProcessedFileTypeRedactedMedicalTranscription         DeidentifyFileOutputProcessedFileType = "redacted_medical_transcription"
	DeidentifyFileOutputProcessedFileTypeRedactedText                         DeidentifyFileOutputProcessedFileType = "redacted_text"
	DeidentifyFileOutputProcessedFileTypeRedactedTranscription                DeidentifyFileOutputProcessedFileType = "redacted_transcription"
)

func NewDeidentifyFileOutputProcessedFileTypeFromString(s string) (DeidentifyFileOutputProcessedFileType, error) {
	switch s {
	case "entities":
		return DeidentifyFileOutputProcessedFileTypeEntities, nil
	case "plaintext_transcription":
		return DeidentifyFileOutputProcessedFileTypePlaintextTranscription, nil
	case "redacted_audio":
		return DeidentifyFileOutputProcessedFileTypeRedactedAudio, nil
	case "redacted_diarized_transcription":
		return DeidentifyFileOutputProcessedFileTypeRedactedDiarizedTranscription, nil
	case "redacted_file":
		return DeidentifyFileOutputProcessedFileTypeRedactedFile, nil
	case "redacted_image":
		return DeidentifyFileOutputProcessedFileTypeRedactedImage, nil
	case "redacted_medical_diarized_transcription":
		return DeidentifyFileOutputProcessedFileTypeRedactedMedicalDiarizedTranscription, nil
	case "redacted_medical_transcription":
		return DeidentifyFileOutputProcessedFileTypeRedactedMedicalTranscription, nil
	case "redacted_text":
		return DeidentifyFileOutputProcessedFileTypeRedactedText, nil
	case "redacted_transcription":
		return DeidentifyFileOutputProcessedFileTypeRedactedTranscription, nil
	}
	var t DeidentifyFileOutputProcessedFileType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyFileOutputProcessedFileType) Ptr() *DeidentifyFileOutputProcessedFileType {
	return &d
}

// Response to de-identify a file.
type DeidentifyFileResponse struct {
	// Status URL for the detect run.
	RunId string `json:"run_id" url:"run_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyFileResponse) GetRunId() string {
	if d == nil {
		return ""
	}
	return d.RunId
}

func (d *DeidentifyFileResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyFileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyFileResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Response to get the status of a detect run.
type DeidentifyStatusResponse struct {
	// Status of the detect run.
	Status DeidentifyStatusResponseStatus `json:"status" url:"status"`
	// How the input file was specified.
	Output []*DeidentifyFileOutput `json:"output" url:"output"`
	// How the output file is specified.
	OutputType *DeidentifyStatusResponseOutputType `json:"output_type,omitempty" url:"output_type,omitempty"`
	// Status details about the detect run.
	Message string `json:"message" url:"message"`
	// Number of words in the processed text.
	WordCount *int `json:"word_count,omitempty" url:"word_count,omitempty"`
	// Number of characters in the processed text.
	CharacterCount *int `json:"character_count,omitempty" url:"character_count,omitempty"`
	// Size of the processed text in kilobytes (KB).
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Duration of the processed audio in seconds.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// Number of pages in the processed PDF.
	Pages *int `json:"pages,omitempty" url:"pages,omitempty"`
	// Number of slides in the processed presentation.
	Slides *int `json:"slides,omitempty" url:"slides,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyStatusResponse) GetStatus() DeidentifyStatusResponseStatus {
	if d == nil {
		return ""
	}
	return d.Status
}

func (d *DeidentifyStatusResponse) GetOutput() []*DeidentifyFileOutput {
	if d == nil {
		return nil
	}
	return d.Output
}

func (d *DeidentifyStatusResponse) GetOutputType() *DeidentifyStatusResponseOutputType {
	if d == nil {
		return nil
	}
	return d.OutputType
}

func (d *DeidentifyStatusResponse) GetMessage() string {
	if d == nil {
		return ""
	}
	return d.Message
}

func (d *DeidentifyStatusResponse) GetWordCount() *int {
	if d == nil {
		return nil
	}
	return d.WordCount
}

func (d *DeidentifyStatusResponse) GetCharacterCount() *int {
	if d == nil {
		return nil
	}
	return d.CharacterCount
}

func (d *DeidentifyStatusResponse) GetSize() *int {
	if d == nil {
		return nil
	}
	return d.Size
}

func (d *DeidentifyStatusResponse) GetDuration() *int {
	if d == nil {
		return nil
	}
	return d.Duration
}

func (d *DeidentifyStatusResponse) GetPages() *int {
	if d == nil {
		return nil
	}
	return d.Pages
}

func (d *DeidentifyStatusResponse) GetSlides() *int {
	if d == nil {
		return nil
	}
	return d.Slides
}

func (d *DeidentifyStatusResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyStatusResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyStatusResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// How the output file is specified.
type DeidentifyStatusResponseOutputType string

const (
	DeidentifyStatusResponseOutputTypeBase64  DeidentifyStatusResponseOutputType = "base64"
	DeidentifyStatusResponseOutputTypeEfsPath DeidentifyStatusResponseOutputType = "efs_path"
)

func NewDeidentifyStatusResponseOutputTypeFromString(s string) (DeidentifyStatusResponseOutputType, error) {
	switch s {
	case "base64":
		return DeidentifyStatusResponseOutputTypeBase64, nil
	case "efs_path":
		return DeidentifyStatusResponseOutputTypeEfsPath, nil
	}
	var t DeidentifyStatusResponseOutputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyStatusResponseOutputType) Ptr() *DeidentifyStatusResponseOutputType {
	return &d
}

// Status of the detect run.
type DeidentifyStatusResponseStatus string

const (
	DeidentifyStatusResponseStatusFailed     DeidentifyStatusResponseStatus = "failed"
	DeidentifyStatusResponseStatusInProgress DeidentifyStatusResponseStatus = "in_progress"
	DeidentifyStatusResponseStatusSuccess    DeidentifyStatusResponseStatus = "success"
)

func NewDeidentifyStatusResponseStatusFromString(s string) (DeidentifyStatusResponseStatus, error) {
	switch s {
	case "failed":
		return DeidentifyStatusResponseStatusFailed, nil
	case "in_progress":
		return DeidentifyStatusResponseStatusInProgress, nil
	case "success":
		return DeidentifyStatusResponseStatusSuccess, nil
	}
	var t DeidentifyStatusResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyStatusResponseStatus) Ptr() *DeidentifyStatusResponseStatus {
	return &d
}

// Response to re-identify a file.
type ReidentifyFileResponse struct {
	// Status of the re-identify operation.
	Status ReidentifyFileResponseStatus `json:"status" url:"status"`
	// Format of the output file.
	Output     *ReidentifyFileResponseOutput `json:"output" url:"output"`
	outputType string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyFileResponse) GetStatus() ReidentifyFileResponseStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ReidentifyFileResponse) GetOutput() *ReidentifyFileResponseOutput {
	if r == nil {
		return nil
	}
	return r.Output
}

func (r *ReidentifyFileResponse) OutputType() string {
	return r.outputType
}

func (r *ReidentifyFileResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyFileResponse) UnmarshalJSON(data []byte) error {
	type embed ReidentifyFileResponse
	var unmarshaler = struct {
		embed
		OutputType string `json:"output_type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ReidentifyFileResponse(unmarshaler.embed)
	if unmarshaler.OutputType != "BASE64" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "BASE64", unmarshaler.OutputType)
	}
	r.outputType = unmarshaler.OutputType
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "output_type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyFileResponse) MarshalJSON() ([]byte, error) {
	type embed ReidentifyFileResponse
	var marshaler = struct {
		embed
		OutputType string `json:"output_type"`
	}{
		embed:      embed(*r),
		OutputType: "BASE64",
	}
	return json.Marshal(marshaler)
}

func (r *ReidentifyFileResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReidentifyFileResponseOutput struct {
	// Re-identified file content in base64 format.
	ProcessedFile string `json:"processed_file" url:"processed_file"`
	// Type of the processed file.
	// Extension of the processed file.
	ProcessedFileExtension string `json:"processed_file_extension" url:"processed_file_extension"`
	processedFileType      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyFileResponseOutput) GetProcessedFile() string {
	if r == nil {
		return ""
	}
	return r.ProcessedFile
}

func (r *ReidentifyFileResponseOutput) GetProcessedFileExtension() string {
	if r == nil {
		return ""
	}
	return r.ProcessedFileExtension
}

func (r *ReidentifyFileResponseOutput) ProcessedFileType() string {
	return r.processedFileType
}

func (r *ReidentifyFileResponseOutput) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyFileResponseOutput) UnmarshalJSON(data []byte) error {
	type embed ReidentifyFileResponseOutput
	var unmarshaler = struct {
		embed
		ProcessedFileType string `json:"processed_file_type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ReidentifyFileResponseOutput(unmarshaler.embed)
	if unmarshaler.ProcessedFileType != "reidentified_file" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "reidentified_file", unmarshaler.ProcessedFileType)
	}
	r.processedFileType = unmarshaler.ProcessedFileType
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "processed_file_type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyFileResponseOutput) MarshalJSON() ([]byte, error) {
	type embed ReidentifyFileResponseOutput
	var marshaler = struct {
		embed
		ProcessedFileType string `json:"processed_file_type"`
	}{
		embed:             embed(*r),
		ProcessedFileType: "reidentified_file",
	}
	return json.Marshal(marshaler)
}

func (r *ReidentifyFileResponseOutput) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Status of the re-identify operation.
type ReidentifyFileResponseStatus string

const (
	ReidentifyFileResponseStatusFailed     ReidentifyFileResponseStatus = "failed"
	ReidentifyFileResponseStatusInProgress ReidentifyFileResponseStatus = "in_progress"
	ReidentifyFileResponseStatusSuccess    ReidentifyFileResponseStatus = "success"
)

func NewReidentifyFileResponseStatusFromString(s string) (ReidentifyFileResponseStatus, error) {
	switch s {
	case "failed":
		return ReidentifyFileResponseStatusFailed, nil
	case "in_progress":
		return ReidentifyFileResponseStatusInProgress, nil
	case "success":
		return ReidentifyFileResponseStatusSuccess, nil
	}
	var t ReidentifyFileResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReidentifyFileResponseStatus) Ptr() *ReidentifyFileResponseStatus {
	return &r
}

// ID of a resource.
type ResourceId = string

// Mapping of tokens to generation for detected entities. Can't be specified together with `token_type`.
type TokenTypeWithoutVault struct {
	Default *TokenTypeWithoutVaultDefault `json:"default,omitempty" url:"default,omitempty"`
	// Entity types to replace with entity tokens with unique counters.
	EntityUnqCounter []EntityType `json:"entity_unq_counter,omitempty" url:"entity_unq_counter,omitempty"`
	// Entity types to replace with entity tokens.
	EntityOnly []EntityType `json:"entity_only,omitempty" url:"entity_only,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenTypeWithoutVault) GetDefault() *TokenTypeWithoutVaultDefault {
	if t == nil {
		return nil
	}
	return t.Default
}

func (t *TokenTypeWithoutVault) GetEntityUnqCounter() []EntityType {
	if t == nil {
		return nil
	}
	return t.EntityUnqCounter
}

func (t *TokenTypeWithoutVault) GetEntityOnly() []EntityType {
	if t == nil {
		return nil
	}
	return t.EntityOnly
}

func (t *TokenTypeWithoutVault) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenTypeWithoutVault) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenTypeWithoutVault
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenTypeWithoutVault(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenTypeWithoutVault) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenTypeWithoutVaultDefault string

const (
	TokenTypeWithoutVaultDefaultEntityOnly       TokenTypeWithoutVaultDefault = "entity_only"
	TokenTypeWithoutVaultDefaultEntityUnqCounter TokenTypeWithoutVaultDefault = "entity_unq_counter"
)

func NewTokenTypeWithoutVaultDefaultFromString(s string) (TokenTypeWithoutVaultDefault, error) {
	switch s {
	case "entity_only":
		return TokenTypeWithoutVaultDefaultEntityOnly, nil
	case "entity_unq_counter":
		return TokenTypeWithoutVaultDefaultEntityUnqCounter, nil
	}
	var t TokenTypeWithoutVaultDefault
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenTypeWithoutVaultDefault) Ptr() *TokenTypeWithoutVaultDefault {
	return &t
}

// UUID.
type Uuid = string

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyAudioRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyAudioRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyAudioRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyAudioRequestFile) GetDataFormat() DeidentifyAudioRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyAudioRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyAudioRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyAudioRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyAudioRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyAudioRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyAudioRequestFileDataFormat string

const (
	DeidentifyAudioRequestFileDataFormatMp3 DeidentifyAudioRequestFileDataFormat = "mp3"
	DeidentifyAudioRequestFileDataFormatWav DeidentifyAudioRequestFileDataFormat = "wav"
)

func NewDeidentifyAudioRequestFileDataFormatFromString(s string) (DeidentifyAudioRequestFileDataFormat, error) {
	switch s {
	case "mp3":
		return DeidentifyAudioRequestFileDataFormatMp3, nil
	case "wav":
		return DeidentifyAudioRequestFileDataFormatWav, nil
	}
	var t DeidentifyAudioRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyAudioRequestFileDataFormat) Ptr() *DeidentifyAudioRequestFileDataFormat {
	return &d
}

// Type of transcription to output.
type DeidentifyAudioRequestOutputTranscription string

const (
	DeidentifyAudioRequestOutputTranscriptionDiarizedTranscription        DeidentifyAudioRequestOutputTranscription = "diarized_transcription"
	DeidentifyAudioRequestOutputTranscriptionMedicalDiarizedTranscription DeidentifyAudioRequestOutputTranscription = "medical_diarized_transcription"
	DeidentifyAudioRequestOutputTranscriptionMedicalTranscription         DeidentifyAudioRequestOutputTranscription = "medical_transcription"
	DeidentifyAudioRequestOutputTranscriptionPlaintextTranscription       DeidentifyAudioRequestOutputTranscription = "plaintext_transcription"
	DeidentifyAudioRequestOutputTranscriptionTranscription                DeidentifyAudioRequestOutputTranscription = "transcription"
)

func NewDeidentifyAudioRequestOutputTranscriptionFromString(s string) (DeidentifyAudioRequestOutputTranscription, error) {
	switch s {
	case "diarized_transcription":
		return DeidentifyAudioRequestOutputTranscriptionDiarizedTranscription, nil
	case "medical_diarized_transcription":
		return DeidentifyAudioRequestOutputTranscriptionMedicalDiarizedTranscription, nil
	case "medical_transcription":
		return DeidentifyAudioRequestOutputTranscriptionMedicalTranscription, nil
	case "plaintext_transcription":
		return DeidentifyAudioRequestOutputTranscriptionPlaintextTranscription, nil
	case "transcription":
		return DeidentifyAudioRequestOutputTranscriptionTranscription, nil
	}
	var t DeidentifyAudioRequestOutputTranscription
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyAudioRequestOutputTranscription) Ptr() *DeidentifyAudioRequestOutputTranscription {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyDocumentRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyDocumentRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyDocumentRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyDocumentRequestFile) GetDataFormat() DeidentifyDocumentRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyDocumentRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyDocumentRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyDocumentRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyDocumentRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyDocumentRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyDocumentRequestFileDataFormat string

const (
	DeidentifyDocumentRequestFileDataFormatDoc  DeidentifyDocumentRequestFileDataFormat = "doc"
	DeidentifyDocumentRequestFileDataFormatDocx DeidentifyDocumentRequestFileDataFormat = "docx"
	DeidentifyDocumentRequestFileDataFormatPdf  DeidentifyDocumentRequestFileDataFormat = "pdf"
)

func NewDeidentifyDocumentRequestFileDataFormatFromString(s string) (DeidentifyDocumentRequestFileDataFormat, error) {
	switch s {
	case "doc":
		return DeidentifyDocumentRequestFileDataFormatDoc, nil
	case "docx":
		return DeidentifyDocumentRequestFileDataFormatDocx, nil
	case "pdf":
		return DeidentifyDocumentRequestFileDataFormatPdf, nil
	}
	var t DeidentifyDocumentRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyDocumentRequestFileDataFormat) Ptr() *DeidentifyDocumentRequestFileDataFormat {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyFileRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyFileRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyFileRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyFileRequestFile) GetDataFormat() DeidentifyFileRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyFileRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyFileRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyFileRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyFileRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyFileRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyFileRequestFileDataFormat string

const (
	DeidentifyFileRequestFileDataFormatBmp  DeidentifyFileRequestFileDataFormat = "bmp"
	DeidentifyFileRequestFileDataFormatCsv  DeidentifyFileRequestFileDataFormat = "csv"
	DeidentifyFileRequestFileDataFormatDcm  DeidentifyFileRequestFileDataFormat = "dcm"
	DeidentifyFileRequestFileDataFormatDoc  DeidentifyFileRequestFileDataFormat = "doc"
	DeidentifyFileRequestFileDataFormatDocx DeidentifyFileRequestFileDataFormat = "docx"
	DeidentifyFileRequestFileDataFormatJpeg DeidentifyFileRequestFileDataFormat = "jpeg"
	DeidentifyFileRequestFileDataFormatJpg  DeidentifyFileRequestFileDataFormat = "jpg"
	DeidentifyFileRequestFileDataFormatJson DeidentifyFileRequestFileDataFormat = "json"
	DeidentifyFileRequestFileDataFormatMp3  DeidentifyFileRequestFileDataFormat = "mp3"
	DeidentifyFileRequestFileDataFormatPdf  DeidentifyFileRequestFileDataFormat = "pdf"
	DeidentifyFileRequestFileDataFormatPng  DeidentifyFileRequestFileDataFormat = "png"
	DeidentifyFileRequestFileDataFormatPpt  DeidentifyFileRequestFileDataFormat = "ppt"
	DeidentifyFileRequestFileDataFormatPptx DeidentifyFileRequestFileDataFormat = "pptx"
	DeidentifyFileRequestFileDataFormatTif  DeidentifyFileRequestFileDataFormat = "tif"
	DeidentifyFileRequestFileDataFormatTiff DeidentifyFileRequestFileDataFormat = "tiff"
	DeidentifyFileRequestFileDataFormatTxt  DeidentifyFileRequestFileDataFormat = "txt"
	DeidentifyFileRequestFileDataFormatWav  DeidentifyFileRequestFileDataFormat = "wav"
	DeidentifyFileRequestFileDataFormatXls  DeidentifyFileRequestFileDataFormat = "xls"
	DeidentifyFileRequestFileDataFormatXlsx DeidentifyFileRequestFileDataFormat = "xlsx"
	DeidentifyFileRequestFileDataFormatXml  DeidentifyFileRequestFileDataFormat = "xml"
)

func NewDeidentifyFileRequestFileDataFormatFromString(s string) (DeidentifyFileRequestFileDataFormat, error) {
	switch s {
	case "bmp":
		return DeidentifyFileRequestFileDataFormatBmp, nil
	case "csv":
		return DeidentifyFileRequestFileDataFormatCsv, nil
	case "dcm":
		return DeidentifyFileRequestFileDataFormatDcm, nil
	case "doc":
		return DeidentifyFileRequestFileDataFormatDoc, nil
	case "docx":
		return DeidentifyFileRequestFileDataFormatDocx, nil
	case "jpeg":
		return DeidentifyFileRequestFileDataFormatJpeg, nil
	case "jpg":
		return DeidentifyFileRequestFileDataFormatJpg, nil
	case "json":
		return DeidentifyFileRequestFileDataFormatJson, nil
	case "mp3":
		return DeidentifyFileRequestFileDataFormatMp3, nil
	case "pdf":
		return DeidentifyFileRequestFileDataFormatPdf, nil
	case "png":
		return DeidentifyFileRequestFileDataFormatPng, nil
	case "ppt":
		return DeidentifyFileRequestFileDataFormatPpt, nil
	case "pptx":
		return DeidentifyFileRequestFileDataFormatPptx, nil
	case "tif":
		return DeidentifyFileRequestFileDataFormatTif, nil
	case "tiff":
		return DeidentifyFileRequestFileDataFormatTiff, nil
	case "txt":
		return DeidentifyFileRequestFileDataFormatTxt, nil
	case "wav":
		return DeidentifyFileRequestFileDataFormatWav, nil
	case "xls":
		return DeidentifyFileRequestFileDataFormatXls, nil
	case "xlsx":
		return DeidentifyFileRequestFileDataFormatXlsx, nil
	case "xml":
		return DeidentifyFileRequestFileDataFormatXml, nil
	}
	var t DeidentifyFileRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyFileRequestFileDataFormat) Ptr() *DeidentifyFileRequestFileDataFormat {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyImageRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyImageRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyImageRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyImageRequestFile) GetDataFormat() DeidentifyImageRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyImageRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyImageRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyImageRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyImageRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyImageRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyImageRequestFileDataFormat string

const (
	DeidentifyImageRequestFileDataFormatBmp  DeidentifyImageRequestFileDataFormat = "bmp"
	DeidentifyImageRequestFileDataFormatJpeg DeidentifyImageRequestFileDataFormat = "jpeg"
	DeidentifyImageRequestFileDataFormatJpg  DeidentifyImageRequestFileDataFormat = "jpg"
	DeidentifyImageRequestFileDataFormatPng  DeidentifyImageRequestFileDataFormat = "png"
	DeidentifyImageRequestFileDataFormatTif  DeidentifyImageRequestFileDataFormat = "tif"
	DeidentifyImageRequestFileDataFormatTiff DeidentifyImageRequestFileDataFormat = "tiff"
)

func NewDeidentifyImageRequestFileDataFormatFromString(s string) (DeidentifyImageRequestFileDataFormat, error) {
	switch s {
	case "bmp":
		return DeidentifyImageRequestFileDataFormatBmp, nil
	case "jpeg":
		return DeidentifyImageRequestFileDataFormatJpeg, nil
	case "jpg":
		return DeidentifyImageRequestFileDataFormatJpg, nil
	case "png":
		return DeidentifyImageRequestFileDataFormatPng, nil
	case "tif":
		return DeidentifyImageRequestFileDataFormatTif, nil
	case "tiff":
		return DeidentifyImageRequestFileDataFormatTiff, nil
	}
	var t DeidentifyImageRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyImageRequestFileDataFormat) Ptr() *DeidentifyImageRequestFileDataFormat {
	return &d
}

// Method to mask the entities in the image.
type DeidentifyImageRequestMaskingMethod string

const (
	DeidentifyImageRequestMaskingMethodBlackbox DeidentifyImageRequestMaskingMethod = "blackbox"
	DeidentifyImageRequestMaskingMethodBlur     DeidentifyImageRequestMaskingMethod = "blur"
)

func NewDeidentifyImageRequestMaskingMethodFromString(s string) (DeidentifyImageRequestMaskingMethod, error) {
	switch s {
	case "blackbox":
		return DeidentifyImageRequestMaskingMethodBlackbox, nil
	case "blur":
		return DeidentifyImageRequestMaskingMethodBlur, nil
	}
	var t DeidentifyImageRequestMaskingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyImageRequestMaskingMethod) Ptr() *DeidentifyImageRequestMaskingMethod {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyPdfRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	dataFormat string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyPdfRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyPdfRequestFile) DataFormat() string {
	return d.dataFormat
}

func (d *DeidentifyPdfRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyPdfRequestFile) UnmarshalJSON(data []byte) error {
	type embed DeidentifyPdfRequestFile
	var unmarshaler = struct {
		embed
		DataFormat string `json:"data_format"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeidentifyPdfRequestFile(unmarshaler.embed)
	if unmarshaler.DataFormat != "pdf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "pdf", unmarshaler.DataFormat)
	}
	d.dataFormat = unmarshaler.DataFormat
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "data_format")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyPdfRequestFile) MarshalJSON() ([]byte, error) {
	type embed DeidentifyPdfRequestFile
	var marshaler = struct {
		embed
		DataFormat string `json:"data_format"`
	}{
		embed:      embed(*d),
		DataFormat: "pdf",
	}
	return json.Marshal(marshaler)
}

func (d *DeidentifyPdfRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyPresentationRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyPresentationRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyPresentationRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyPresentationRequestFile) GetDataFormat() DeidentifyPresentationRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyPresentationRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyPresentationRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyPresentationRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyPresentationRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyPresentationRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyPresentationRequestFileDataFormat string

const (
	DeidentifyPresentationRequestFileDataFormatPpt  DeidentifyPresentationRequestFileDataFormat = "ppt"
	DeidentifyPresentationRequestFileDataFormatPptx DeidentifyPresentationRequestFileDataFormat = "pptx"
)

func NewDeidentifyPresentationRequestFileDataFormatFromString(s string) (DeidentifyPresentationRequestFileDataFormat, error) {
	switch s {
	case "ppt":
		return DeidentifyPresentationRequestFileDataFormatPpt, nil
	case "pptx":
		return DeidentifyPresentationRequestFileDataFormatPptx, nil
	}
	var t DeidentifyPresentationRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyPresentationRequestFileDataFormat) Ptr() *DeidentifyPresentationRequestFileDataFormat {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifySpreadsheetRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifySpreadsheetRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifySpreadsheetRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifySpreadsheetRequestFile) GetDataFormat() DeidentifySpreadsheetRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifySpreadsheetRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifySpreadsheetRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifySpreadsheetRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifySpreadsheetRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifySpreadsheetRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifySpreadsheetRequestFileDataFormat string

const (
	DeidentifySpreadsheetRequestFileDataFormatCsv  DeidentifySpreadsheetRequestFileDataFormat = "csv"
	DeidentifySpreadsheetRequestFileDataFormatXls  DeidentifySpreadsheetRequestFileDataFormat = "xls"
	DeidentifySpreadsheetRequestFileDataFormatXlsx DeidentifySpreadsheetRequestFileDataFormat = "xlsx"
)

func NewDeidentifySpreadsheetRequestFileDataFormatFromString(s string) (DeidentifySpreadsheetRequestFileDataFormat, error) {
	switch s {
	case "csv":
		return DeidentifySpreadsheetRequestFileDataFormatCsv, nil
	case "xls":
		return DeidentifySpreadsheetRequestFileDataFormatXls, nil
	case "xlsx":
		return DeidentifySpreadsheetRequestFileDataFormatXlsx, nil
	}
	var t DeidentifySpreadsheetRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifySpreadsheetRequestFileDataFormat) Ptr() *DeidentifySpreadsheetRequestFileDataFormat {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyStructuredTextRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat DeidentifyStructuredTextRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyStructuredTextRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyStructuredTextRequestFile) GetDataFormat() DeidentifyStructuredTextRequestFileDataFormat {
	if d == nil {
		return ""
	}
	return d.DataFormat
}

func (d *DeidentifyStructuredTextRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyStructuredTextRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DeidentifyStructuredTextRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeidentifyStructuredTextRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyStructuredTextRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Data format of the file.
type DeidentifyStructuredTextRequestFileDataFormat string

const (
	DeidentifyStructuredTextRequestFileDataFormatJson DeidentifyStructuredTextRequestFileDataFormat = "json"
	DeidentifyStructuredTextRequestFileDataFormatXml  DeidentifyStructuredTextRequestFileDataFormat = "xml"
)

func NewDeidentifyStructuredTextRequestFileDataFormatFromString(s string) (DeidentifyStructuredTextRequestFileDataFormat, error) {
	switch s {
	case "json":
		return DeidentifyStructuredTextRequestFileDataFormatJson, nil
	case "xml":
		return DeidentifyStructuredTextRequestFileDataFormatXml, nil
	}
	var t DeidentifyStructuredTextRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeidentifyStructuredTextRequestFileDataFormat) Ptr() *DeidentifyStructuredTextRequestFileDataFormat {
	return &d
}

// File to de-identify. Files are specified as Base64-encoded data.
type DeidentifyTextRequestFile struct {
	// Base64-encoded data of the file to de-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	dataFormat string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeidentifyTextRequestFile) GetBase64() string {
	if d == nil {
		return ""
	}
	return d.Base64
}

func (d *DeidentifyTextRequestFile) DataFormat() string {
	return d.dataFormat
}

func (d *DeidentifyTextRequestFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeidentifyTextRequestFile) UnmarshalJSON(data []byte) error {
	type embed DeidentifyTextRequestFile
	var unmarshaler = struct {
		embed
		DataFormat string `json:"data_format"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeidentifyTextRequestFile(unmarshaler.embed)
	if unmarshaler.DataFormat != "txt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "txt", unmarshaler.DataFormat)
	}
	d.dataFormat = unmarshaler.DataFormat
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "data_format")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeidentifyTextRequestFile) MarshalJSON() ([]byte, error) {
	type embed DeidentifyTextRequestFile
	var marshaler = struct {
		embed
		DataFormat string `json:"data_format"`
	}{
		embed:      embed(*d),
		DataFormat: "txt",
	}
	return json.Marshal(marshaler)
}

func (d *DeidentifyTextRequestFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// File to re-identify. Files are specified as Base64-encoded data or an EFS path.
type ReidentifyFileRequestFile struct {
	// Base64-encoded data of the file to re-identify.
	Base64 string `json:"base64" url:"base64"`
	// Data format of the file.
	DataFormat ReidentifyFileRequestFileDataFormat `json:"data_format" url:"data_format"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyFileRequestFile) GetBase64() string {
	if r == nil {
		return ""
	}
	return r.Base64
}

func (r *ReidentifyFileRequestFile) GetDataFormat() ReidentifyFileRequestFileDataFormat {
	if r == nil {
		return ""
	}
	return r.DataFormat
}

func (r *ReidentifyFileRequestFile) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyFileRequestFile) UnmarshalJSON(data []byte) error {
	type unmarshaler ReidentifyFileRequestFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReidentifyFileRequestFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyFileRequestFile) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Data format of the file.
type ReidentifyFileRequestFileDataFormat string

const (
	ReidentifyFileRequestFileDataFormatCsv  ReidentifyFileRequestFileDataFormat = "csv"
	ReidentifyFileRequestFileDataFormatDoc  ReidentifyFileRequestFileDataFormat = "doc"
	ReidentifyFileRequestFileDataFormatDocx ReidentifyFileRequestFileDataFormat = "docx"
	ReidentifyFileRequestFileDataFormatJson ReidentifyFileRequestFileDataFormat = "json"
	ReidentifyFileRequestFileDataFormatTxt  ReidentifyFileRequestFileDataFormat = "txt"
	ReidentifyFileRequestFileDataFormatXls  ReidentifyFileRequestFileDataFormat = "xls"
	ReidentifyFileRequestFileDataFormatXlsx ReidentifyFileRequestFileDataFormat = "xlsx"
	ReidentifyFileRequestFileDataFormatXml  ReidentifyFileRequestFileDataFormat = "xml"
)

func NewReidentifyFileRequestFileDataFormatFromString(s string) (ReidentifyFileRequestFileDataFormat, error) {
	switch s {
	case "csv":
		return ReidentifyFileRequestFileDataFormatCsv, nil
	case "doc":
		return ReidentifyFileRequestFileDataFormatDoc, nil
	case "docx":
		return ReidentifyFileRequestFileDataFormatDocx, nil
	case "json":
		return ReidentifyFileRequestFileDataFormatJson, nil
	case "txt":
		return ReidentifyFileRequestFileDataFormatTxt, nil
	case "xls":
		return ReidentifyFileRequestFileDataFormatXls, nil
	case "xlsx":
		return ReidentifyFileRequestFileDataFormatXlsx, nil
	case "xml":
		return ReidentifyFileRequestFileDataFormatXml, nil
	}
	var t ReidentifyFileRequestFileDataFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReidentifyFileRequestFileDataFormat) Ptr() *ReidentifyFileRequestFileDataFormat {
	return &r
}

// Mapping of preferred data formatting options to entity types. Returned values are dependent on the configuration of the vault storing the data and the permissions of the user or account making the request.
type ReidentifyFileRequestFormat struct {
	// Entity types to fully redact.
	Redacted []EntityType `json:"redacted,omitempty" url:"redacted,omitempty"`
	// Entity types to mask.
	Masked []EntityType `json:"masked,omitempty" url:"masked,omitempty"`
	// Entity types to return in plaintext.
	Plaintext []EntityType `json:"plaintext,omitempty" url:"plaintext,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReidentifyFileRequestFormat) GetRedacted() []EntityType {
	if r == nil {
		return nil
	}
	return r.Redacted
}

func (r *ReidentifyFileRequestFormat) GetMasked() []EntityType {
	if r == nil {
		return nil
	}
	return r.Masked
}

func (r *ReidentifyFileRequestFormat) GetPlaintext() []EntityType {
	if r == nil {
		return nil
	}
	return r.Plaintext
}

func (r *ReidentifyFileRequestFormat) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReidentifyFileRequestFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler ReidentifyFileRequestFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReidentifyFileRequestFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReidentifyFileRequestFormat) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
