/*
Skyflow Data API

# Data API  This API inserts, retrieves, and otherwise manages data in a vaultapi.  The Data API is available from two base URIs. *identifier* is the identifier in your vaultapi's URL.<ul><li><b>Sandbox:</b> https://_*identifier*.vaultapi.skyflowapis-preview.com</li><li><b>Production:</b> https://_*identifier*.vaultapi.skyflowapis.com</li></ul>  When you make an API call, you need to add a header: <table><tr><th>Header</th><th>Value</th><th>Example</th></tr><tr><td>Authorization</td><td>A Bearer Token. See <a href='/api-authentication/'>API Authentication</a>.</td><td><code>Authorization: Bearer eyJhbGciOiJSUzI...1NiIsJdfPA</code></td></tr><table/>

API version: v1
Contact: support@skyflow.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vaultapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
)


// RecordsAPIService RecordsAPI service
type RecordsAPIService service

type RecordsAPIFileServiceDeleteFileRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	tableName string
	iD string
	columnName string
}

func (r RecordsAPIFileServiceDeleteFileRequest) Execute() (*V1DeleteFileResponse, *http.Response, error) {
	return r.ApiService.FileServiceDeleteFileExecute(r)
}

/*
FileServiceDeleteFile Delete File

Deletes a file from the specified record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param tableName Name of the table.
 @param iD `skyflow_id` of the record.
 @param columnName Name of the column that contains the file.
 @return RecordsAPIFileServiceDeleteFileRequest
*/
func (a *RecordsAPIService) FileServiceDeleteFile(ctx context.Context, vaultID string, tableName string, iD string, columnName string) RecordsAPIFileServiceDeleteFileRequest {
	return RecordsAPIFileServiceDeleteFileRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		tableName: tableName,
		iD: iD,
		columnName: columnName,
	}
}

// Execute executes the request
//  @return V1DeleteFileResponse
func (a *RecordsAPIService) FileServiceDeleteFileExecute(r RecordsAPIFileServiceDeleteFileRequest) (*V1DeleteFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeleteFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.FileServiceDeleteFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnName"+"}", url.PathEscape(parameterValueToString(r.columnName, "columnName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIFileServiceGetFileScanStatusRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	tableName string
	iD string
	columnName string
}

func (r RecordsAPIFileServiceGetFileScanStatusRequest) Execute() (*V1GetFileScanStatusResponse, *http.Response, error) {
	return r.ApiService.FileServiceGetFileScanStatusExecute(r)
}

/*
FileServiceGetFileScanStatus Get File Scan Status

Returns the anti-virus scan status of a file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param tableName Name of the table.
 @param iD `skyflow_id` of the record.
 @param columnName Name of the column that contains the file.
 @return RecordsAPIFileServiceGetFileScanStatusRequest
*/
func (a *RecordsAPIService) FileServiceGetFileScanStatus(ctx context.Context, vaultID string, tableName string, iD string, columnName string) RecordsAPIFileServiceGetFileScanStatusRequest {
	return RecordsAPIFileServiceGetFileScanStatusRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		tableName: tableName,
		iD: iD,
		columnName: columnName,
	}
}

// Execute executes the request
//  @return V1GetFileScanStatusResponse
func (a *RecordsAPIService) FileServiceGetFileScanStatusExecute(r RecordsAPIFileServiceGetFileScanStatusRequest) (*V1GetFileScanStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GetFileScanStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.FileServiceGetFileScanStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}/scan-status"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnName"+"}", url.PathEscape(parameterValueToString(r.columnName, "columnName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIFileServiceUploadFileRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	iD string
	fileColumnName *os.File
}

// Name of the column to store the file in. The column must have a file data type.
func (r RecordsAPIFileServiceUploadFileRequest) FileColumnName(fileColumnName *os.File) RecordsAPIFileServiceUploadFileRequest {
	r.fileColumnName = fileColumnName
	return r
}

func (r RecordsAPIFileServiceUploadFileRequest) Execute() (*V1UpdateRecordResponse, *http.Response, error) {
	return r.ApiService.FileServiceUploadFileExecute(r)
}

/*
FileServiceUploadFile Upload File

Uploads a file to the specified record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @param iD `skyflow_id` of the record.
 @return RecordsAPIFileServiceUploadFileRequest
*/
func (a *RecordsAPIService) FileServiceUploadFile(ctx context.Context, vaultID string, objectName string, iD string) RecordsAPIFileServiceUploadFileRequest {
	return RecordsAPIFileServiceUploadFileRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
		iD: iD,
	}
}

// Execute executes the request
//  @return V1UpdateRecordResponse
func (a *RecordsAPIService) FileServiceUploadFileExecute(r RecordsAPIFileServiceUploadFileRequest) (*V1UpdateRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UpdateRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.FileServiceUploadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}/{ID}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileColumnNameLocalVarFormFileName string
	var fileColumnNameLocalVarFileName     string
	var fileColumnNameLocalVarFileBytes    []byte

	fileColumnNameLocalVarFormFileName = "fileColumnName"
	fileColumnNameLocalVarFile := r.fileColumnName

	if fileColumnNameLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileColumnNameLocalVarFile)

		fileColumnNameLocalVarFileBytes = fbs
		fileColumnNameLocalVarFileName = fileColumnNameLocalVarFile.Name()
		fileColumnNameLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileColumnNameLocalVarFileBytes, fileName: fileColumnNameLocalVarFileName, formFileName: fileColumnNameLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceBatchOperationRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	body *RecordServiceBatchOperationBody
}

func (r RecordsAPIRecordServiceBatchOperationRequest) Body(body RecordServiceBatchOperationBody) RecordsAPIRecordServiceBatchOperationRequest {
	r.body = &body
	return r
}

func (r RecordsAPIRecordServiceBatchOperationRequest) Execute() (*V1BatchOperationResponse, *http.Response, error) {
	return r.ApiService.RecordServiceBatchOperationExecute(r)
}

/*
RecordServiceBatchOperation Batch Operation

Performs multiple record operations in a single transaction.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @return RecordsAPIRecordServiceBatchOperationRequest
*/
func (a *RecordsAPIService) RecordServiceBatchOperation(ctx context.Context, vaultID string) RecordsAPIRecordServiceBatchOperationRequest {
	return RecordsAPIRecordServiceBatchOperationRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
	}
}

// Execute executes the request
//  @return V1BatchOperationResponse
func (a *RecordsAPIService) RecordServiceBatchOperationExecute(r RecordsAPIRecordServiceBatchOperationRequest) (*V1BatchOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BatchOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceBatchOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceBulkDeleteRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	body *RecordServiceBulkDeleteRecordBody
}

func (r RecordsAPIRecordServiceBulkDeleteRecordRequest) Body(body RecordServiceBulkDeleteRecordBody) RecordsAPIRecordServiceBulkDeleteRecordRequest {
	r.body = &body
	return r
}

func (r RecordsAPIRecordServiceBulkDeleteRecordRequest) Execute() (*V1BulkDeleteRecordResponse, *http.Response, error) {
	return r.ApiService.RecordServiceBulkDeleteRecordExecute(r)
}

/*
RecordServiceBulkDeleteRecord Bulk Delete Records

Deletes the specified records from a table.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @return RecordsAPIRecordServiceBulkDeleteRecordRequest
*/
func (a *RecordsAPIService) RecordServiceBulkDeleteRecord(ctx context.Context, vaultID string, objectName string) RecordsAPIRecordServiceBulkDeleteRecordRequest {
	return RecordsAPIRecordServiceBulkDeleteRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
	}
}

// Execute executes the request
//  @return V1BulkDeleteRecordResponse
func (a *RecordsAPIService) RecordServiceBulkDeleteRecordExecute(r RecordsAPIRecordServiceBulkDeleteRecordRequest) (*V1BulkDeleteRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BulkDeleteRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceBulkDeleteRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceBulkGetRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	skyflowIds *[]string
	redaction *string
	tokenization *bool
	fields *[]string
	offset *string
	limit *string
	downloadURL *bool
	columnName *string
	columnValues *[]string
	orderBy *string
}

// &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) SkyflowIds(skyflowIds []string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.skyflowIds = &skyflowIds
	return r
}

// Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) Redaction(redaction string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.redaction = &redaction
	return r
}

// If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) Tokenization(tokenization bool) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.tokenization = &tokenization
	return r
}

// Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) Fields(fields []string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.fields = &fields
	return r
}

// Record position at which to start receiving data.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) Offset(offset string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.offset = &offset
	return r
}

// Number of record to return. Maximum 25.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) Limit(limit string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.limit = &limit
	return r
}

// If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) DownloadURL(downloadURL bool) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.downloadURL = &downloadURL
	return r
}

// Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) ColumnName(columnName string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.columnName = &columnName
	return r
}

// Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) ColumnValues(columnValues []string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.columnValues = &columnValues
	return r
}

// Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
func (r RecordsAPIRecordServiceBulkGetRecordRequest) OrderBy(orderBy string) RecordsAPIRecordServiceBulkGetRecordRequest {
	r.orderBy = &orderBy
	return r
}

func (r RecordsAPIRecordServiceBulkGetRecordRequest) Execute() (*V1BulkGetRecordResponse, *http.Response, error) {
	return r.ApiService.RecordServiceBulkGetRecordExecute(r)
}

/*
RecordServiceBulkGetRecord Get Record(s)

Gets the specified records from a table.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table that contains the records.
 @return RecordsAPIRecordServiceBulkGetRecordRequest
*/
func (a *RecordsAPIService) RecordServiceBulkGetRecord(ctx context.Context, vaultID string, objectName string) RecordsAPIRecordServiceBulkGetRecordRequest {
	return RecordsAPIRecordServiceBulkGetRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
	}
}

// Execute executes the request
//  @return V1BulkGetRecordResponse
func (a *RecordsAPIService) RecordServiceBulkGetRecordExecute(r RecordsAPIRecordServiceBulkGetRecordRequest) (*V1BulkGetRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BulkGetRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceBulkGetRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skyflowIds != nil {
		t := *r.skyflowIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "skyflow_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "skyflow_ids", t, "form", "multi")
		}
	}
	if r.redaction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redaction", r.redaction, "form", "")
	} else {
		var defaultValue string = "DEFAULT"
		r.redaction = &defaultValue
	}
	if r.tokenization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenization", r.tokenization, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = "25"
		r.limit = &defaultValue
	}
	if r.downloadURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "downloadURL", r.downloadURL, "form", "")
	}
	if r.columnName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "column_name", r.columnName, "form", "")
	}
	if r.columnValues != nil {
		t := *r.columnValues
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "column_values", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "column_values", t, "form", "multi")
		}
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	} else {
		var defaultValue string = "ASCENDING"
		r.orderBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceDeleteRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	iD string
}

func (r RecordsAPIRecordServiceDeleteRecordRequest) Execute() (*V1DeleteRecordResponse, *http.Response, error) {
	return r.ApiService.RecordServiceDeleteRecordExecute(r)
}

/*
RecordServiceDeleteRecord Delete Record

Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn't delete transient field tokens. Transient field values are available until they expire based on the fields' time-to-live (TTL) setting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @param iD `skyflow_id` of the record to delete.
 @return RecordsAPIRecordServiceDeleteRecordRequest
*/
func (a *RecordsAPIService) RecordServiceDeleteRecord(ctx context.Context, vaultID string, objectName string, iD string) RecordsAPIRecordServiceDeleteRecordRequest {
	return RecordsAPIRecordServiceDeleteRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
		iD: iD,
	}
}

// Execute executes the request
//  @return V1DeleteRecordResponse
func (a *RecordsAPIService) RecordServiceDeleteRecordExecute(r RecordsAPIRecordServiceDeleteRecordRequest) (*V1DeleteRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeleteRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceDeleteRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}/{ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceGetRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	iD string
	redaction *string
	tokenization *bool
	fields *[]string
	downloadURL *bool
}

// Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
func (r RecordsAPIRecordServiceGetRecordRequest) Redaction(redaction string) RecordsAPIRecordServiceGetRecordRequest {
	r.redaction = &redaction
	return r
}

// If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
func (r RecordsAPIRecordServiceGetRecordRequest) Tokenization(tokenization bool) RecordsAPIRecordServiceGetRecordRequest {
	r.tokenization = &tokenization
	return r
}

// Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
func (r RecordsAPIRecordServiceGetRecordRequest) Fields(fields []string) RecordsAPIRecordServiceGetRecordRequest {
	r.fields = &fields
	return r
}

// If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
func (r RecordsAPIRecordServiceGetRecordRequest) DownloadURL(downloadURL bool) RecordsAPIRecordServiceGetRecordRequest {
	r.downloadURL = &downloadURL
	return r
}

func (r RecordsAPIRecordServiceGetRecordRequest) Execute() (*V1FieldRecords, *http.Response, error) {
	return r.ApiService.RecordServiceGetRecordExecute(r)
}

/*
RecordServiceGetRecord Get Record By ID

Returns the specified record from a table.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @param iD `skyflow_id` of the record.
 @return RecordsAPIRecordServiceGetRecordRequest
*/
func (a *RecordsAPIService) RecordServiceGetRecord(ctx context.Context, vaultID string, objectName string, iD string) RecordsAPIRecordServiceGetRecordRequest {
	return RecordsAPIRecordServiceGetRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
		iD: iD,
	}
}

// Execute executes the request
//  @return V1FieldRecords
func (a *RecordsAPIService) RecordServiceGetRecordExecute(r RecordsAPIRecordServiceGetRecordRequest) (*V1FieldRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1FieldRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceGetRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}/{ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.redaction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redaction", r.redaction, "form", "")
	} else {
		var defaultValue string = "DEFAULT"
		r.redaction = &defaultValue
	}
	if r.tokenization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenization", r.tokenization, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.downloadURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "downloadURL", r.downloadURL, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceInsertRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	body *RecordServiceInsertRecordBody
}

func (r RecordsAPIRecordServiceInsertRecordRequest) Body(body RecordServiceInsertRecordBody) RecordsAPIRecordServiceInsertRecordRequest {
	r.body = &body
	return r
}

func (r RecordsAPIRecordServiceInsertRecordRequest) Execute() (*V1InsertRecordResponse, *http.Response, error) {
	return r.ApiService.RecordServiceInsertRecordExecute(r)
}

/*
RecordServiceInsertRecord Insert Records

Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @return RecordsAPIRecordServiceInsertRecordRequest
*/
func (a *RecordsAPIService) RecordServiceInsertRecord(ctx context.Context, vaultID string, objectName string) RecordsAPIRecordServiceInsertRecordRequest {
	return RecordsAPIRecordServiceInsertRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
	}
}

// Execute executes the request
//  @return V1InsertRecordResponse
func (a *RecordsAPIService) RecordServiceInsertRecordExecute(r RecordsAPIRecordServiceInsertRecordRequest) (*V1InsertRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1InsertRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceInsertRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordsAPIRecordServiceUpdateRecordRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	vaultID string
	objectName string
	iD string
	body *RecordServiceUpdateRecordBody
}

func (r RecordsAPIRecordServiceUpdateRecordRequest) Body(body RecordServiceUpdateRecordBody) RecordsAPIRecordServiceUpdateRecordRequest {
	r.body = &body
	return r
}

func (r RecordsAPIRecordServiceUpdateRecordRequest) Execute() (*V1UpdateRecordResponse, *http.Response, error) {
	return r.ApiService.RecordServiceUpdateRecordExecute(r)
}

/*
RecordServiceUpdateRecord Update Record

Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultID ID of the vaultapi.
 @param objectName Name of the table.
 @param iD `skyflow_id` of the record.
 @return RecordsAPIRecordServiceUpdateRecordRequest
*/
func (a *RecordsAPIService) RecordServiceUpdateRecord(ctx context.Context, vaultID string, objectName string, iD string) RecordsAPIRecordServiceUpdateRecordRequest {
	return RecordsAPIRecordServiceUpdateRecordRequest{
		ApiService: a,
		ctx: ctx,
		vaultID: vaultID,
		objectName: objectName,
		iD: iD,
	}
}

// Execute executes the request
//  @return V1UpdateRecordResponse
func (a *RecordsAPIService) RecordServiceUpdateRecordExecute(r RecordsAPIRecordServiceUpdateRecordRequest) (*V1UpdateRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UpdateRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.RecordServiceUpdateRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{vaultID}/{objectName}/{ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"vaultID"+"}", url.PathEscape(parameterValueToString(r.vaultID, "vaultID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectName"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
