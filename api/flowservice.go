// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/skyflowapi/skyflow-go/internal"
)

type V1DeleteRequest struct {
	// ID of the vault where data is being deleted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being deleted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be deleted
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
}

type V1DeleteTokenRequest struct {
	// Vault ID
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token value
	Tokens []string `json:"tokens,omitempty" url:"-"`
}

type V1DetokenizeRequest struct {
	// ID of the vault where detokenizing
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token to be detokenized
	Tokens []string `json:"tokens,omitempty" url:"-"`
	// List of token groups to be redacted.
	TokenGroupRedactions []*V1TokenGroupRedactions `json:"tokenGroupRedactions,omitempty" url:"-"`
}

type V1GetRequest struct {
	// ID of the vault where data is being fetched
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being fetched
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be fetched
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
	// List of columns to be redacted.
	ColumnRedactions []*V1ColumnRedactions `json:"columnRedactions,omitempty" url:"-"`
	// List of columns to be fetched.
	Columns []string `json:"columns,omitempty" url:"-"`
	// Limit for the number of records to be fetched
	Limit *int `json:"limit,omitempty" url:"-"`
	// Offset for the number of records to be fetched
	Offset *int `json:"offset,omitempty" url:"-"`
}

type V1InsertRequest struct {
	// ID of the vault where data is being inserted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being inserted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be inserted in the vault
	Records []*V1InsertRecordData `json:"records,omitempty" url:"-"`
	// Name of a unique columns in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.
	Upsert []string `json:"upsert,omitempty" url:"-"`
}

type V1TokenizeRequest struct {
	// Vault ID.
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Data to be tokenized
	Data []*V1TokenizeRequestObject `json:"data,omitempty" url:"-"`
}

type EnumDataType string

const (
	EnumDataTypeUndefinedDatatype EnumDataType = "UNDEFINED_DATATYPE"
	EnumDataTypeString            EnumDataType = "STRING"
	EnumDataTypeNumber            EnumDataType = "NUMBER"
	EnumDataTypeBool              EnumDataType = "BOOL"
	EnumDataTypeJson              EnumDataType = "JSON"
)

func NewEnumDataTypeFromString(s string) (EnumDataType, error) {
	switch s {
	case "UNDEFINED_DATATYPE":
		return EnumDataTypeUndefinedDatatype, nil
	case "STRING":
		return EnumDataTypeString, nil
	case "NUMBER":
		return EnumDataTypeNumber, nil
	case "BOOL":
		return EnumDataTypeBool, nil
	case "JSON":
		return EnumDataTypeJson, nil
	}
	var t EnumDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumDataType) Ptr() *EnumDataType {
	return &e
}

type TokenizeResponseObjectToken struct {
	// Token group Name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Token value
	Token *string `json:"token,omitempty" url:"token,omitempty"`
	// Error if tokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeResponseObjectToken) GetTokenGroupName() *string {
	if t == nil {
		return nil
	}
	return t.TokenGroupName
}

func (t *TokenizeResponseObjectToken) GetToken() *string {
	if t == nil {
		return nil
	}
	return t.Token
}

func (t *TokenizeResponseObjectToken) GetError() *string {
	if t == nil {
		return nil
	}
	return t.Error
}

func (t *TokenizeResponseObjectToken) GetHttpCode() *int {
	if t == nil {
		return nil
	}
	return t.HttpCode
}

func (t *TokenizeResponseObjectToken) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeResponseObjectToken) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponseObjectToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponseObjectToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponseObjectToken) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type V1ColumnRedactions struct {
	// Name of the column to be redacted
	ColumnName *string `json:"columnName,omitempty" url:"columnName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1ColumnRedactions) GetColumnName() *string {
	if v == nil {
		return nil
	}
	return v.ColumnName
}

func (v *V1ColumnRedactions) GetRedaction() *string {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1ColumnRedactions) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ColumnRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ColumnRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ColumnRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ColumnRedactions) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteResponse struct {
	// List of deleted records with skyflow ID and any partial errors.
	Records []*V1DeleteResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteResponse) GetRecords() []*V1DeleteResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1DeleteResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteResponseObject struct {
	// Skyflow ID for the deleted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteResponseObject) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1DeleteResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DeleteResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1DeleteResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteTokenResponseObject struct {
	// Token value
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Error if deletion failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteTokenResponseObject) GetValue() *string {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1DeleteTokenResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DeleteTokenResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1DeleteTokenResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteTokenResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteTokenResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteTokenResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteTokenResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1GetResponse struct {
	// List of fetched records with skyflow ID, tokens, data, and any partial errors
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1GetResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1GetResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1GetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1GetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1GetResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1GetResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1InsertRecordData struct {
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1InsertRecordData) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1InsertRecordData) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1InsertRecordData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InsertRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InsertRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InsertRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InsertRecordData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1InsertResponse struct {
	// List of inserted records with skyflow ID, tokens, data, and any partial errors.
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1InsertResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1InsertResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InsertResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1RecordResponseObject struct {
	// Skyflow ID for the inserted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1RecordResponseObject) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1RecordResponseObject) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1RecordResponseObject) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1RecordResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1RecordResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1RecordResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1RecordResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1RecordResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1RecordResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1RecordResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenGroupRedactions struct {
	// Name of the token group to be redacted
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenGroupRedactions) GetTokenGroupName() *string {
	if v == nil {
		return nil
	}
	return v.TokenGroupName
}

func (v *V1TokenGroupRedactions) GetRedaction() *string {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1TokenGroupRedactions) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenGroupRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenGroupRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenGroupRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenGroupRedactions) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateRecordData struct {
	// Skyflow ID for the record to be updated
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// List of data row wise that is to be updated in the vault
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1UpdateRecordData) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1UpdateRecordData) GetData() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *V1UpdateRecordData) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1UpdateRecordData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateRecordData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateResponse struct {
	// List of updated records with skyflow ID, tokens, data, and any partial errors
	Records []*V1RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1UpdateResponse) GetRecords() []*V1RecordResponseObject {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1UpdateResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteTokenResponse struct {
	// Tokens data for Delete
	Tokens []*V1DeleteTokenResponseObject `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteTokenResponse) GetTokens() []*V1DeleteTokenResponseObject {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1DeleteTokenResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteTokenResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DetokenizeResponse struct {
	// Detokenized data
	Response []*V1DetokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DetokenizeResponse) GetResponse() []*V1DetokenizeResponseObject {
	if v == nil {
		return nil
	}
	return v.Response
}

func (v *V1DetokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DetokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DetokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DetokenizeResponseObject struct {
	// Token to be detokenized
	Token *string     `json:"token,omitempty" url:"token,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token group name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Error if detokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`
	// Additional metadata associated with the token, such as tableName or skyflowID
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DetokenizeResponseObject) GetToken() *string {
	if v == nil {
		return nil
	}
	return v.Token
}

func (v *V1DetokenizeResponseObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1DetokenizeResponseObject) GetTokenGroupName() *string {
	if v == nil {
		return nil
	}
	return v.TokenGroupName
}

func (v *V1DetokenizeResponseObject) GetError() *string {
	if v == nil {
		return nil
	}
	return v.Error
}

func (v *V1DetokenizeResponseObject) GetHttpCode() *int {
	if v == nil {
		return nil
	}
	return v.HttpCode
}

func (v *V1DetokenizeResponseObject) GetMetadata() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Metadata
}

func (v *V1DetokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DetokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DetokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DetokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DetokenizeResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeRequestObject struct {
	Value    interface{}   `json:"value,omitempty" url:"value,omitempty"`
	DataType *EnumDataType `json:"dataType,omitempty" url:"dataType,omitempty"`
	// List of token group names
	TokenGroupNames []string `json:"tokenGroupNames,omitempty" url:"tokenGroupNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeRequestObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1TokenizeRequestObject) GetDataType() *EnumDataType {
	if v == nil {
		return nil
	}
	return v.DataType
}

func (v *V1TokenizeRequestObject) GetTokenGroupNames() []string {
	if v == nil {
		return nil
	}
	return v.TokenGroupNames
}

func (v *V1TokenizeRequestObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeRequestObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeRequestObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeRequestObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeRequestObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeResponse struct {
	// Tokenized data
	Response []*V1TokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeResponse) GetResponse() []*V1TokenizeResponseObject {
	if v == nil {
		return nil
	}
	return v.Response
}

func (v *V1TokenizeResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1TokenizeResponseObject struct {
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token value
	Tokens []*TokenizeResponseObjectToken `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1TokenizeResponseObject) GetValue() interface{} {
	if v == nil {
		return nil
	}
	return v.Value
}

func (v *V1TokenizeResponseObject) GetTokens() []*TokenizeResponseObjectToken {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1TokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TokenizeResponseObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateRequest struct {
	// ID of the vault where data is being updated
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being updated
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be updated in the vault
	Records []*V1UpdateRecordData `json:"records,omitempty" url:"-"`
}
