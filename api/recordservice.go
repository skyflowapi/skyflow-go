// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/internal"
)

type DeleteRequest struct {
	// ID of the vault where data is being deleted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being deleted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be deleted
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
}

type DeleteTokenRequest struct {
	// Vault ID
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token value
	Tokens []string `json:"tokens,omitempty" url:"-"`
}

type DetokenizeRequest struct {
	// ID of the vault where detokenizing
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Token to be detokenized
	Tokens []string `json:"tokens,omitempty" url:"-"`
	// List of token groups to be redacted.
	TokenGroupRedactions []*TokenGroupRedactions `json:"tokenGroupRedactions,omitempty" url:"-"`
}

type GetRequest struct {
	// ID of the vault where data is being fetched
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being fetched
	TableName *string `json:"tableName,omitempty" url:"-"`
	// Skyflow ID for the record to be fetched
	SkyflowIDs []string `json:"skyflowIDs,omitempty" url:"-"`
	// List of columns to be redacted.
	ColumnRedactions []*ColumnRedactions `json:"columnRedactions,omitempty" url:"-"`
	// List of columns to be fetched.
	Columns []string `json:"columns,omitempty" url:"-"`
	// Limit for the number of records to be fetched
	Limit *int `json:"limit,omitempty" url:"-"`
	// Offset for the number of records to be fetched
	Offset *int `json:"offset,omitempty" url:"-"`
}

type InsertRequest struct {
	// ID of the vault where data is being inserted
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being inserted
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be inserted in the vault
	Records []*InsertRecordData `json:"records,omitempty" url:"-"`
	Upsert  *Upsert             `json:"upsert,omitempty" url:"-"`
}

type TokenizeRequest struct {
	// Vault ID.
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Data to be tokenized
	Data []*TokenizeRequestObject `json:"data,omitempty" url:"-"`
}

type ColumnRedactions struct {
	// Name of the column to be redacted
	ColumnName *string `json:"columnName,omitempty" url:"columnName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ColumnRedactions) GetColumnName() *string {
	if c == nil {
		return nil
	}
	return c.ColumnName
}

func (c *ColumnRedactions) GetRedaction() *string {
	if c == nil {
		return nil
	}
	return c.Redaction
}

func (c *ColumnRedactions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ColumnRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler ColumnRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColumnRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColumnRedactions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeleteResponse struct {
	// List of deleted records with skyflow ID and any partial errors.
	Records []*DeleteResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteResponse) GetRecords() []*DeleteResponseObject {
	if d == nil {
		return nil
	}
	return d.Records
}

func (d *DeleteResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteResponseObject struct {
	// Skyflow ID for the deleted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteResponseObject) GetSkyflowId() *string {
	if d == nil {
		return nil
	}
	return d.SkyflowId
}

func (d *DeleteResponseObject) GetError() *string {
	if d == nil {
		return nil
	}
	return d.Error
}

func (d *DeleteResponseObject) GetHttpCode() *int {
	if d == nil {
		return nil
	}
	return d.HttpCode
}

func (d *DeleteResponseObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteResponseObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteTokenResponse struct {
	// Tokens data for Delete
	Tokens []*DeleteTokenResponseObject `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteTokenResponse) GetTokens() []*DeleteTokenResponseObject {
	if d == nil {
		return nil
	}
	return d.Tokens
}

func (d *DeleteTokenResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteTokenResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteTokenResponseObject struct {
	// Token value
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Error if deletion failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteTokenResponseObject) GetValue() *string {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DeleteTokenResponseObject) GetError() *string {
	if d == nil {
		return nil
	}
	return d.Error
}

func (d *DeleteTokenResponseObject) GetHttpCode() *int {
	if d == nil {
		return nil
	}
	return d.HttpCode
}

func (d *DeleteTokenResponseObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteTokenResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteTokenResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteTokenResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteTokenResponseObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DetokenizeResponse struct {
	// Detokenized data
	Response []*DetokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DetokenizeResponse) GetResponse() []*DetokenizeResponseObject {
	if d == nil {
		return nil
	}
	return d.Response
}

func (d *DetokenizeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetokenizeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DetokenizeResponseObject struct {
	// Token to be detokenized
	Token *string     `json:"token,omitempty" url:"token,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token group name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Error if detokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`
	// Additional metadata associated with the token, such as tableName or skyflowID
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DetokenizeResponseObject) GetToken() *string {
	if d == nil {
		return nil
	}
	return d.Token
}

func (d *DetokenizeResponseObject) GetValue() interface{} {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DetokenizeResponseObject) GetTokenGroupName() *string {
	if d == nil {
		return nil
	}
	return d.TokenGroupName
}

func (d *DetokenizeResponseObject) GetError() *string {
	if d == nil {
		return nil
	}
	return d.Error
}

func (d *DetokenizeResponseObject) GetHttpCode() *int {
	if d == nil {
		return nil
	}
	return d.HttpCode
}

func (d *DetokenizeResponseObject) GetMetadata() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Metadata
}

func (d *DetokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DetokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetokenizeResponseObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumDataType string

const (
	EnumDataTypeUndefinedDatatype EnumDataType = "UNDEFINED_DATATYPE"
	EnumDataTypeString            EnumDataType = "STRING"
	EnumDataTypeNumber            EnumDataType = "NUMBER"
	EnumDataTypeBool              EnumDataType = "BOOL"
	EnumDataTypeJson              EnumDataType = "JSON"
)

func NewEnumDataTypeFromString(s string) (EnumDataType, error) {
	switch s {
	case "UNDEFINED_DATATYPE":
		return EnumDataTypeUndefinedDatatype, nil
	case "STRING":
		return EnumDataTypeString, nil
	case "NUMBER":
		return EnumDataTypeNumber, nil
	case "BOOL":
		return EnumDataTypeBool, nil
	case "JSON":
		return EnumDataTypeJson, nil
	}
	var t EnumDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumDataType) Ptr() *EnumDataType {
	return &e
}

type EnumUpdateType string

const (
	EnumUpdateTypeUpdate  EnumUpdateType = "UPDATE"
	EnumUpdateTypeReplace EnumUpdateType = "REPLACE"
)

func NewEnumUpdateTypeFromString(s string) (EnumUpdateType, error) {
	switch s {
	case "UPDATE":
		return EnumUpdateTypeUpdate, nil
	case "REPLACE":
		return EnumUpdateTypeReplace, nil
	}
	var t EnumUpdateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumUpdateType) Ptr() *EnumUpdateType {
	return &e
}

type GetResponse struct {
	// List of fetched records with skyflow ID, tokens, data, and any partial errors
	Records []*RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetResponse) GetRecords() []*RecordResponseObject {
	if g == nil {
		return nil
	}
	return g.Records
}

func (g *GetResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InsertRecordData struct {
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsertRecordData) GetData() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InsertRecordData) GetTokens() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Tokens
}

func (i *InsertRecordData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsertRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler InsertRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsertRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsertRecordData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InsertResponse struct {
	// List of inserted records with skyflow ID, tokens, data, and any partial errors.
	Records []*RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsertResponse) GetRecords() []*RecordResponseObject {
	if i == nil {
		return nil
	}
	return i.Records
}

func (i *InsertResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsertResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type RecordResponseObject struct {
	// Skyflow ID for the inserted record
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`
	// Columns names and values
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Hashed Data for the columns if any
	HashedData map[string]interface{} `json:"hashedData,omitempty" url:"hashedData,omitempty"`
	// Partial Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RecordResponseObject) GetSkyflowId() *string {
	if r == nil {
		return nil
	}
	return r.SkyflowId
}

func (r *RecordResponseObject) GetTokens() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Tokens
}

func (r *RecordResponseObject) GetData() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RecordResponseObject) GetHashedData() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.HashedData
}

func (r *RecordResponseObject) GetError() *string {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *RecordResponseObject) GetHttpCode() *int {
	if r == nil {
		return nil
	}
	return r.HttpCode
}

func (r *RecordResponseObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordResponseObject) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type TokenGroupRedactions struct {
	// Name of the token group to be redacted
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Name of the redaction. Eg: `plain_text`, `redacted`, `mask1`
	Redaction *string `json:"redaction,omitempty" url:"redaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGroupRedactions) GetTokenGroupName() *string {
	if t == nil {
		return nil
	}
	return t.TokenGroupName
}

func (t *TokenGroupRedactions) GetRedaction() *string {
	if t == nil {
		return nil
	}
	return t.Redaction
}

func (t *TokenGroupRedactions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGroupRedactions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGroupRedactions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGroupRedactions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGroupRedactions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenizeRequestObject struct {
	Value    interface{}   `json:"value,omitempty" url:"value,omitempty"`
	DataType *EnumDataType `json:"dataType,omitempty" url:"dataType,omitempty"`
	// List of token group names
	TokenGroupNames []string `json:"tokenGroupNames,omitempty" url:"tokenGroupNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeRequestObject) GetValue() interface{} {
	if t == nil {
		return nil
	}
	return t.Value
}

func (t *TokenizeRequestObject) GetDataType() *EnumDataType {
	if t == nil {
		return nil
	}
	return t.DataType
}

func (t *TokenizeRequestObject) GetTokenGroupNames() []string {
	if t == nil {
		return nil
	}
	return t.TokenGroupNames
}

func (t *TokenizeRequestObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeRequestObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeRequestObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeRequestObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeRequestObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenizeResponse struct {
	// Tokenized data
	Response []*TokenizeResponseObject `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeResponse) GetResponse() []*TokenizeResponseObject {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *TokenizeResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponse) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenizeResponseObject struct {
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Token value
	Tokens []*TokenizeResponseObjectToken `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeResponseObject) GetValue() interface{} {
	if t == nil {
		return nil
	}
	return t.Value
}

func (t *TokenizeResponseObject) GetTokens() []*TokenizeResponseObjectToken {
	if t == nil {
		return nil
	}
	return t.Tokens
}

func (t *TokenizeResponseObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponseObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenizeResponseObjectToken struct {
	// Token group Name
	TokenGroupName *string `json:"tokenGroupName,omitempty" url:"tokenGroupName,omitempty"`
	// Token value
	Token *string `json:"token,omitempty" url:"token,omitempty"`
	// Error if tokenization failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// HTTP status code of the response
	HttpCode *int `json:"httpCode,omitempty" url:"httpCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeResponseObjectToken) GetTokenGroupName() *string {
	if t == nil {
		return nil
	}
	return t.TokenGroupName
}

func (t *TokenizeResponseObjectToken) GetToken() *string {
	if t == nil {
		return nil
	}
	return t.Token
}

func (t *TokenizeResponseObjectToken) GetError() *string {
	if t == nil {
		return nil
	}
	return t.Error
}

func (t *TokenizeResponseObjectToken) GetHttpCode() *int {
	if t == nil {
		return nil
	}
	return t.HttpCode
}

func (t *TokenizeResponseObjectToken) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeResponseObjectToken) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponseObjectToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponseObjectToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponseObjectToken) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateRecordData struct {
	// Skyflow ID for the record to be updated
	SkyflowId *string `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	// List of data row wise that is to be updated in the vault
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Tokens data for the columns if any
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateRecordData) GetSkyflowId() *string {
	if u == nil {
		return nil
	}
	return u.SkyflowId
}

func (u *UpdateRecordData) GetData() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpdateRecordData) GetTokens() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Tokens
}

func (u *UpdateRecordData) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRecordData) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateRecordData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateRecordData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRecordData) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateResponse struct {
	// List of updated records with skyflow ID, tokens, data, and any partial errors
	Records []*RecordResponseObject `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateResponse) GetRecords() []*RecordResponseObject {
	if u == nil {
		return nil
	}
	return u.Records
}

func (u *UpdateResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type Upsert struct {
	UpdateType *EnumUpdateType `json:"updateType,omitempty" url:"updateType,omitempty"`
	// Name of a unique columns in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.
	UniqueColumns []string `json:"uniqueColumns,omitempty" url:"uniqueColumns,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *Upsert) GetUpdateType() *EnumUpdateType {
	if u == nil {
		return nil
	}
	return u.UpdateType
}

func (u *Upsert) GetUniqueColumns() []string {
	if u == nil {
		return nil
	}
	return u.UniqueColumns
}

func (u *Upsert) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Upsert) UnmarshalJSON(data []byte) error {
	type unmarshaler Upsert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Upsert(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *Upsert) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRequest struct {
	// ID of the vault where data is being updated
	VaultId *string `json:"vaultID,omitempty" url:"-"`
	// Name of the table where data is being updated
	TableName *string `json:"tableName,omitempty" url:"-"`
	// List of data row wise that is to be updated in the vault
	Records    []*UpdateRecordData `json:"records,omitempty" url:"-"`
	UpdateType *EnumUpdateType     `json:"updateType,omitempty" url:"-"`
}
