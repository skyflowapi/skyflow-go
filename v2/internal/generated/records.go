// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/skyflowapi/skyflow-go/v2/internal/generated/internal"
	io "io"
)

type FileServiceUploadFileRequest struct {
	File io.Reader `json:"-" url:"-"`
	// Name of the column to store the file in. The column must have a file data type.
	ColumnName *string `json:"columnName,omitempty" url:"-"`
}

type RecordServiceBatchOperationBody struct {
	// Record operations to perform.
	Records []*V1BatchRecord `json:"records,omitempty" url:"-"`
	// Continue performing operations on partial errors.
	ContinueOnError *bool   `json:"continueOnError,omitempty" url:"-"`
	Byot            *V1Byot `json:"byot,omitempty" url:"-"`
}

type RecordServiceBulkDeleteRecordBody struct {
	// `skyflow_id` values of the records to delete. If `*` is specified, this operation deletes all records in the table.
	SkyflowIds []string `json:"skyflow_ids,omitempty" url:"-"`
}

type RecordServiceBulkGetRecordRequest struct {
	// `skyflow_id` values of the records to return, with one value per `skyflow_ids` URL parameter. For example, `?skyflow_ids=abc&skyflow_ids=123`.<br /><br />If not specified, returns the first 25 records in the table.
	SkyflowIds []*string `json:"-" url:"skyflow_ids,omitempty"`
	// Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
	Redaction *RecordServiceBulkGetRecordRequestRedaction `json:"-" url:"redaction,omitempty"`
	// If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.
	Tokenization *bool `json:"-" url:"tokenization,omitempty"`
	// Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.
	Fields []*string `json:"-" url:"fields,omitempty"`
	// Record position at which to start receiving data.
	Offset *string `json:"-" url:"offset,omitempty"`
	// Number of record to return. Maximum 25.
	Limit *string `json:"-" url:"limit,omitempty"`
	// If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
	DownloadUrl *bool `json:"-" url:"downloadURL,omitempty"`
	// Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.
	ColumnName *string `json:"-" url:"column_name,omitempty"`
	// Column values of the records to return, with one value per `column_values` URL parameter. For example, `?column_values=abc&column_values=123`.<br /><br />`column_name` is mandatory when providing `column_values`. If you use column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.
	ColumnValues []*string `json:"-" url:"column_values,omitempty"`
	// Order to return records, based on `skyflow_id` values. To disable, set to `NONE`.
	OrderBy *RecordServiceBulkGetRecordRequestOrderBy `json:"-" url:"order_by,omitempty"`
}

type RecordServiceGetRecordRequest struct {
	// Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
	Redaction *RecordServiceGetRecordRequestRedaction `json:"-" url:"redaction,omitempty"`
	// If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.
	Tokenization *bool `json:"-" url:"tokenization,omitempty"`
	// Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.
	Fields []*string `json:"-" url:"fields,omitempty"`
	// If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
	DownloadUrl *bool `json:"-" url:"downloadURL,omitempty"`
}

type RecordServiceInsertRecordBody struct {
	// Record values and tokens.
	Records []*V1FieldRecords `json:"records,omitempty" url:"-"`
	// If `true`, this operation returns tokens for fields with tokenization enabled.
	Tokenization *bool `json:"tokenization,omitempty" url:"-"`
	// Name of a unique column in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.<br /><br />When you upsert a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.
	Upsert *string `json:"upsert,omitempty" url:"-"`
	// If `true`, this operation mandates that all the records have the same fields. This parameter does not work with upsert.
	Homogeneous *bool   `json:"homogeneous,omitempty" url:"-"`
	Byot        *V1Byot `json:"byot,omitempty" url:"-"`
}

type RecordServiceUpdateRecordBody struct {
	Record *V1FieldRecords `json:"record,omitempty" url:"-"`
	// If `true`, this operation returns tokens for fields with tokenization enabled.
	Tokenization *bool   `json:"tokenization,omitempty" url:"-"`
	Byot         *V1Byot `json:"byot,omitempty" url:"-"`
}

// Method of the operation.
type BatchRecordMethod string

const (
	BatchRecordMethodNone   BatchRecordMethod = "NONE"
	BatchRecordMethodPost   BatchRecordMethod = "POST"
	BatchRecordMethodPut    BatchRecordMethod = "PUT"
	BatchRecordMethodGet    BatchRecordMethod = "GET"
	BatchRecordMethodDelete BatchRecordMethod = "DELETE"
)

func NewBatchRecordMethodFromString(s string) (BatchRecordMethod, error) {
	switch s {
	case "NONE":
		return BatchRecordMethodNone, nil
	case "POST":
		return BatchRecordMethodPost, nil
	case "PUT":
		return BatchRecordMethodPut, nil
	case "GET":
		return BatchRecordMethodGet, nil
	case "DELETE":
		return BatchRecordMethodDelete, nil
	}
	var t BatchRecordMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BatchRecordMethod) Ptr() *BatchRecordMethod {
	return &b
}

// Response schema for uploading a file, optionally creating a new record.
type UploadFileV2Response struct {
	// Skyflow ID of the record the file was uploaded to.
	SkyflowId    *string     `json:"skyflowID,omitempty" url:"skyflowID,omitempty"`
	FileMetadata interface{} `json:"fileMetadata,omitempty" url:"fileMetadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UploadFileV2Response) GetSkyflowId() *string {
	if u == nil {
		return nil
	}
	return u.SkyflowId
}

func (u *UploadFileV2Response) GetFileMetadata() interface{} {
	if u == nil {
		return nil
	}
	return u.FileMetadata
}

func (u *UploadFileV2Response) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UploadFileV2Response) UnmarshalJSON(data []byte) error {
	type unmarshaler UploadFileV2Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UploadFileV2Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UploadFileV2Response) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type V1BatchOperationResponse struct {
	// ID of the vault.
	VaultId *string `json:"vaultID,omitempty" url:"vaultID,omitempty"`
	// Responses in the same order as in the request. Responses have the same payload structure as their corresponding APIs: <br/><ul><li>`POST` returns an Insert Records response.</li><li>`PUT` returns an Update Record response.</li><li>`GET` returns a Get Record response.</li><li>`DELETE` returns a Delete Record response.</li></ul>
	Responses []map[string]interface{} `json:"responses,omitempty" url:"responses,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1BatchOperationResponse) GetVaultId() *string {
	if v == nil {
		return nil
	}
	return v.VaultId
}

func (v *V1BatchOperationResponse) GetResponses() []map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Responses
}

func (v *V1BatchOperationResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1BatchOperationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1BatchOperationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1BatchOperationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1BatchOperationResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1BatchRecord struct {
	// Field and value key pairs. For example, `{'field_1':'value_1', 'field_2':'value_2'}`. Only valid when `method` is `POST` or `PUT`.
	Fields map[string]interface{} `json:"fields,omitempty" url:"fields,omitempty"`
	// Name of the table to perform the operation on.
	TableName *string            `json:"tableName,omitempty" url:"tableName,omitempty"`
	Method    *BatchRecordMethod `json:"method,omitempty" url:"method,omitempty"`
	// ID to group operations by. Operations in the same group are executed sequentially.
	BatchId   *string                 `json:"batchID,omitempty" url:"batchID,omitempty"`
	Redaction *RedactionEnumRedaction `json:"redaction,omitempty" url:"redaction,omitempty"`
	// If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.
	Tokenization *bool `json:"tokenization,omitempty" url:"tokenization,omitempty"`
	// `skyflow_id` for the record. Only valid when `method` is `GET`, `DELETE`, or `PUT`.
	Id *string `json:"ID,omitempty" url:"ID,omitempty"`
	// If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
	DownloadUrl *bool `json:"downloadURL,omitempty" url:"downloadURL,omitempty"`
	// Column that stores primary keys for upsert operations. The column must be marked as unique in the vault schema. Only valid when `method` is `POST`.
	Upsert *string `json:"upsert,omitempty" url:"upsert,omitempty"`
	// Fields and tokens for the record. For example, `{'field_1':'token_1', 'field_2':'token_2'}`.
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1BatchRecord) GetFields() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Fields
}

func (v *V1BatchRecord) GetTableName() *string {
	if v == nil {
		return nil
	}
	return v.TableName
}

func (v *V1BatchRecord) GetMethod() *BatchRecordMethod {
	if v == nil {
		return nil
	}
	return v.Method
}

func (v *V1BatchRecord) GetBatchId() *string {
	if v == nil {
		return nil
	}
	return v.BatchId
}

func (v *V1BatchRecord) GetRedaction() *RedactionEnumRedaction {
	if v == nil {
		return nil
	}
	return v.Redaction
}

func (v *V1BatchRecord) GetTokenization() *bool {
	if v == nil {
		return nil
	}
	return v.Tokenization
}

func (v *V1BatchRecord) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *V1BatchRecord) GetDownloadUrl() *bool {
	if v == nil {
		return nil
	}
	return v.DownloadUrl
}

func (v *V1BatchRecord) GetUpsert() *string {
	if v == nil {
		return nil
	}
	return v.Upsert
}

func (v *V1BatchRecord) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1BatchRecord) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1BatchRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler V1BatchRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1BatchRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1BatchRecord) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1BulkDeleteRecordResponse struct {
	// IDs for the deleted records, or `*` if all records were deleted.
	RecordIdResponse []string `json:"RecordIDResponse,omitempty" url:"RecordIDResponse,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1BulkDeleteRecordResponse) GetRecordIdResponse() []string {
	if v == nil {
		return nil
	}
	return v.RecordIdResponse
}

func (v *V1BulkDeleteRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1BulkDeleteRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1BulkDeleteRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1BulkDeleteRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1BulkDeleteRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1BulkGetRecordResponse struct {
	// The specified records.
	Records []*V1FieldRecords `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1BulkGetRecordResponse) GetRecords() []*V1FieldRecords {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1BulkGetRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1BulkGetRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1BulkGetRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1BulkGetRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1BulkGetRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Token insertion behavior.
//
//   - DISABLE: Tokens aren't allowed for any fields. If tokens are specified, the request fails.
//   - ENABLE: Tokens are allowed—but not required—for all fields. If tokens are specified, they're inserted.
//   - ENABLE_STRICT: Tokens are required for all fields. If tokens are specified, they're inserted. If not, the request fails.
type V1Byot string

const (
	V1ByotDisable      V1Byot = "DISABLE"
	V1ByotEnable       V1Byot = "ENABLE"
	V1ByotEnableStrict V1Byot = "ENABLE_STRICT"
)

func NewV1ByotFromString(s string) (V1Byot, error) {
	switch s {
	case "DISABLE":
		return V1ByotDisable, nil
	case "ENABLE":
		return V1ByotEnable, nil
	case "ENABLE_STRICT":
		return V1ByotEnableStrict, nil
	}
	var t V1Byot
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1Byot) Ptr() *V1Byot {
	return &v
}

type V1DeleteFileResponse struct {
	// ID of the record.
	SkyflowId *string `json:"skyflow_id,omitempty" url:"skyflow_id,omitempty"`
	// If `true`, the file was deleted.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteFileResponse) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1DeleteFileResponse) GetDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.Deleted
}

func (v *V1DeleteFileResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteFileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteFileResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1DeleteRecordResponse struct {
	// ID of the deleted record.
	SkyflowId *string `json:"skyflow_id,omitempty" url:"skyflow_id,omitempty"`
	// If `true`, the record was deleted.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1DeleteRecordResponse) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1DeleteRecordResponse) GetDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.Deleted
}

func (v *V1DeleteRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1DeleteRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1DeleteRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1DeleteRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1DeleteRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Anti-virus scan status of the file.
type V1FileAvScanStatus string

const (
	V1FileAvScanStatusScanNone         V1FileAvScanStatus = "SCAN_NONE"
	V1FileAvScanStatusScanClean        V1FileAvScanStatus = "SCAN_CLEAN"
	V1FileAvScanStatusScanInfected     V1FileAvScanStatus = "SCAN_INFECTED"
	V1FileAvScanStatusScanDeleted      V1FileAvScanStatus = "SCAN_DELETED"
	V1FileAvScanStatusScanError        V1FileAvScanStatus = "SCAN_ERROR"
	V1FileAvScanStatusScanPending      V1FileAvScanStatus = "SCAN_PENDING"
	V1FileAvScanStatusScanUnscannable  V1FileAvScanStatus = "SCAN_UNSCANNABLE"
	V1FileAvScanStatusScanFileNotFound V1FileAvScanStatus = "SCAN_FILE_NOT_FOUND"
	V1FileAvScanStatusScanInvalid      V1FileAvScanStatus = "SCAN_INVALID"
)

func NewV1FileAvScanStatusFromString(s string) (V1FileAvScanStatus, error) {
	switch s {
	case "SCAN_NONE":
		return V1FileAvScanStatusScanNone, nil
	case "SCAN_CLEAN":
		return V1FileAvScanStatusScanClean, nil
	case "SCAN_INFECTED":
		return V1FileAvScanStatusScanInfected, nil
	case "SCAN_DELETED":
		return V1FileAvScanStatusScanDeleted, nil
	case "SCAN_ERROR":
		return V1FileAvScanStatusScanError, nil
	case "SCAN_PENDING":
		return V1FileAvScanStatusScanPending, nil
	case "SCAN_UNSCANNABLE":
		return V1FileAvScanStatusScanUnscannable, nil
	case "SCAN_FILE_NOT_FOUND":
		return V1FileAvScanStatusScanFileNotFound, nil
	case "SCAN_INVALID":
		return V1FileAvScanStatusScanInvalid, nil
	}
	var t V1FileAvScanStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1FileAvScanStatus) Ptr() *V1FileAvScanStatus {
	return &v
}

type V1GetFileScanStatusResponse struct {
	AvScanStatus *V1FileAvScanStatus `json:"av_scan_status,omitempty" url:"av_scan_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1GetFileScanStatusResponse) GetAvScanStatus() *V1FileAvScanStatus {
	if v == nil {
		return nil
	}
	return v.AvScanStatus
}

func (v *V1GetFileScanStatusResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1GetFileScanStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1GetFileScanStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1GetFileScanStatusResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1GetFileScanStatusResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1InsertRecordResponse struct {
	// Identifiers for the inserted records.
	Records []*V1RecordMetaProperties `json:"records,omitempty" url:"records,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1InsertRecordResponse) GetRecords() []*V1RecordMetaProperties {
	if v == nil {
		return nil
	}
	return v.Records
}

func (v *V1InsertRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InsertRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InsertRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InsertRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InsertRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1RecordMetaProperties struct {
	// ID of the inserted record.
	SkyflowId *string `json:"skyflow_id,omitempty" url:"skyflow_id,omitempty"`
	// Tokens for the record.
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1RecordMetaProperties) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1RecordMetaProperties) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1RecordMetaProperties) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1RecordMetaProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler V1RecordMetaProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1RecordMetaProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1RecordMetaProperties) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1UpdateRecordResponse struct {
	// ID of the updated record.
	SkyflowId *string `json:"skyflow_id,omitempty" url:"skyflow_id,omitempty"`
	// Tokens for the record.
	Tokens map[string]interface{} `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V1UpdateRecordResponse) GetSkyflowId() *string {
	if v == nil {
		return nil
	}
	return v.SkyflowId
}

func (v *V1UpdateRecordResponse) GetTokens() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Tokens
}

func (v *V1UpdateRecordResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateRecordResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type RecordServiceBulkGetRecordRequestOrderBy string

const (
	RecordServiceBulkGetRecordRequestOrderByAscending  RecordServiceBulkGetRecordRequestOrderBy = "ASCENDING"
	RecordServiceBulkGetRecordRequestOrderByDescending RecordServiceBulkGetRecordRequestOrderBy = "DESCENDING"
	RecordServiceBulkGetRecordRequestOrderByNone       RecordServiceBulkGetRecordRequestOrderBy = "NONE"
)

func NewRecordServiceBulkGetRecordRequestOrderByFromString(s string) (RecordServiceBulkGetRecordRequestOrderBy, error) {
	switch s {
	case "ASCENDING":
		return RecordServiceBulkGetRecordRequestOrderByAscending, nil
	case "DESCENDING":
		return RecordServiceBulkGetRecordRequestOrderByDescending, nil
	case "NONE":
		return RecordServiceBulkGetRecordRequestOrderByNone, nil
	}
	var t RecordServiceBulkGetRecordRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RecordServiceBulkGetRecordRequestOrderBy) Ptr() *RecordServiceBulkGetRecordRequestOrderBy {
	return &r
}

type RecordServiceBulkGetRecordRequestRedaction string

const (
	RecordServiceBulkGetRecordRequestRedactionDefault   RecordServiceBulkGetRecordRequestRedaction = "DEFAULT"
	RecordServiceBulkGetRecordRequestRedactionRedacted  RecordServiceBulkGetRecordRequestRedaction = "REDACTED"
	RecordServiceBulkGetRecordRequestRedactionMasked    RecordServiceBulkGetRecordRequestRedaction = "MASKED"
	RecordServiceBulkGetRecordRequestRedactionPlainText RecordServiceBulkGetRecordRequestRedaction = "PLAIN_TEXT"
)

func NewRecordServiceBulkGetRecordRequestRedactionFromString(s string) (RecordServiceBulkGetRecordRequestRedaction, error) {
	switch s {
	case "DEFAULT":
		return RecordServiceBulkGetRecordRequestRedactionDefault, nil
	case "REDACTED":
		return RecordServiceBulkGetRecordRequestRedactionRedacted, nil
	case "MASKED":
		return RecordServiceBulkGetRecordRequestRedactionMasked, nil
	case "PLAIN_TEXT":
		return RecordServiceBulkGetRecordRequestRedactionPlainText, nil
	}
	var t RecordServiceBulkGetRecordRequestRedaction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RecordServiceBulkGetRecordRequestRedaction) Ptr() *RecordServiceBulkGetRecordRequestRedaction {
	return &r
}

type RecordServiceGetRecordRequestRedaction string

const (
	RecordServiceGetRecordRequestRedactionDefault   RecordServiceGetRecordRequestRedaction = "DEFAULT"
	RecordServiceGetRecordRequestRedactionRedacted  RecordServiceGetRecordRequestRedaction = "REDACTED"
	RecordServiceGetRecordRequestRedactionMasked    RecordServiceGetRecordRequestRedaction = "MASKED"
	RecordServiceGetRecordRequestRedactionPlainText RecordServiceGetRecordRequestRedaction = "PLAIN_TEXT"
)

func NewRecordServiceGetRecordRequestRedactionFromString(s string) (RecordServiceGetRecordRequestRedaction, error) {
	switch s {
	case "DEFAULT":
		return RecordServiceGetRecordRequestRedactionDefault, nil
	case "REDACTED":
		return RecordServiceGetRecordRequestRedactionRedacted, nil
	case "MASKED":
		return RecordServiceGetRecordRequestRedactionMasked, nil
	case "PLAIN_TEXT":
		return RecordServiceGetRecordRequestRedactionPlainText, nil
	}
	var t RecordServiceGetRecordRequestRedaction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RecordServiceGetRecordRequestRedaction) Ptr() *RecordServiceGetRecordRequestRedaction {
	return &r
}

type UploadFileV2Request struct {
	File io.Reader `json:"-" url:"-"`
	// Name of the table to upload the file to.
	TableName string `json:"tableName" url:"-"`
	// Name of the column to upload the file to. The column must have a `file` data type.
	ColumnName string `json:"columnName" url:"-"`
	// Skyflow ID of the record to upload the file to. If `skyflowID` isn't specified, a new record will be created.
	SkyflowId *string `json:"skyflowID,omitempty" url:"-"`
	// If `true`, returns metadata about the uploaded file.
	ReturnFileMetadata *bool `json:"returnFileMetadata,omitempty" url:"-"`
}
